<!-- TOC -->

- [1. kafka](#1-kafka)
    - [1.1. kafka的高可用性](#11-kafka的高可用性)
    - [1.2. kafka的多种ack场景](#12-kafka的多种ack场景)
        - [1.2.1. acks=0](#121-acks0)
        - [1.2.2. ack=1](#122-ack1)
        - [1.2.3. ack=-1](#123-ack-1)
        - [1.2.4. ISR](#124-isr)
    - [1.3. kafka丢消息的问题](#13-kafka丢消息的问题)
        - [1.3.1. 同步刷盘和异步刷盘的区别](#131-同步刷盘和异步刷盘的区别)
        - [1.3.2. kafka丢消息的原因](#132-kafka丢消息的原因)
            - [1.3.2.1. 在broker中丢失消息](#1321-在broker中丢失消息)
            - [1.3.2.2. 在producer中丢失消息](#1322-在producer中丢失消息)
            - [1.3.2.3. 在Consumer中出现消息丢失](#1323-在consumer中出现消息丢失)
                - [1.3.2.3.1. 消费步骤](#13231-消费步骤)
                - [1.3.2.3.2. 消费方式](#13232-消费方式)
                - [1.3.2.3.3. consumer丢失消息代码分析](#13233-consumer丢失消息代码分析)

<!-- /TOC -->
# 1. kafka
## 1.1. kafka的高可用性
Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。

这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。

Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。


![avator](https://raw.githubusercontent.com/doocs/advanced-java/master/images/kafka-after.png)

这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。

写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）

消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。

看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。

## 1.2. kafka的多种ack场景
### 1.2.1. acks=0
producer不等待broker的响应，效率最高，但是消息很可能会丢。

### 1.2.2. ack=1
acks=1，leader broker收到消息后，不等待其他follower的响应，即返回ack。也可以理解为ack数为1。此时，如果follower还没有收到leader同步的消息leader就挂了，那么消息会丢失。按照上图中的例子，如果leader收到消息，成功写入PageCache后，会返回ack，此时producer认为消息发送成功。但此时，按照上图，数据还没有被同步到follower。如果此时leader断电，数据会丢失。

### 1.2.3. ack=-1
acks=-1，leader broker收到消息后，挂起，等待所有ISR列表中的follower返回结果后，再返回ack。-1等效与all。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack。如果此时断电，producer可以知道消息没有被发送成功，将会重新发送。如果在follower收到数据以后，成功返回ack，leader断电，数据将存在于原来的follower中。

在重新选举以后，新的leader会持有该部分数据。数据从leader同步到follower，需要2步：
- 数据从pageCache被刷盘到disk。因为只有disk中的数据才能被同步到replica。
- 数据同步到replica，并且replica成功将数据写入PageCache。在producer得到ack后，哪怕是所有机器都停电，数据也至少会存在于leader的磁盘内。


### 1.2.4. ISR
上面第三点提到了ISR的列表的follower，需要配合另一个参数才能更好的保证ack的有效性。ISR是Broker维护的一个“可靠的follower列表”，in-sync Replica列表，broker的配置包含一个参数：min.insync.replicas。该参数表示ISR中最少的副本数。如果不设置该值，ISR中的follower列表可能为空。此时相当于acks=1。

![avator](https://blackdog.oss-cn-qingdao.aliyuncs.com/blog/kfk-lost-2.jpg/sp)

## 1.3. kafka丢消息的问题
### 1.3.1. 同步刷盘和异步刷盘的区别
![avator](https://upload-images.jianshu.io/upload_images/5475068-4399932f6471e662?imageMogr2/auto-orient/strip|imageView2/2/w/585)

同步刷盘是在每条消息都确认落盘了之后才向发送者返回响应；而异步刷盘中，只要消息保存到Broker的内存就向发送者返回响应，Broker会有专门的线程对内存中的消息进行批量存储。所以异步刷盘的策略下，当机器突然掉电时，Broker内存中的消息因无法刷到磁盘导致丢失。

### 1.3.2. kafka丢消息的原因
[参考](https://blog.dogchao.cn/?p=305)
![avator](https://blackdog.oss-cn-qingdao.aliyuncs.com/blog/kfk-lost-1.jpg/s)
Kafka存在丢消息的问题，消息丢失会发生在Broker，Producer和Consumer三种。

#### 1.3.2.1. 在broker中丢失消息
Broker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将数据存储到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。

![avator](https://blackdog.oss-cn-qingdao.aliyuncs.com/blog/kfk-lost-5.png/s)

上图简述了broker写数据以及同步的一个过程。broker写数据只写到PageCache中，而pageCache位于内存。这部分数据在断电后是会丢失的。pageCache的数据通过linux的flusher程序进行刷盘。刷盘触发条件有三：

- 主动调用sync或fsync函数
- 可用内存低于阀值
- dirty：data时间达到阀值。dirty是pagecache的一个标识位，当有数据写入到pageCache时，pagecache被标注为dirty，数据刷盘以后，dirty标志清除。


Broker配置刷盘机制，是通过调用fsync函数接管了刷盘动作。从单个Broker来看，pageCache的数据会丢失。

#### 1.3.2.2. 在producer中丢失消息
为了提升效率，减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。缓存的方式和前文提到的刷盘类似，producer可以将请求打包成“块”或者按照时间间隔，将buffer中的数据发出。通过buffer我们可以将生产者改造为异步的方式，而这可以提升我们的发送效率。

但是，buffer中的数据就是危险的。在正常情况下，客户端的异步调用可以通过callback来处理消息发送失败或者超时的情况，但是，一旦producer被非法的停止了，那么buffer中的数据将丢失，broker将无法收到该部分数据。又或者，当Producer客户端内存不够时，如果采取的策略是丢弃消息（另一种策略是block阻塞），消息也会被丢失。抑或，消息产生（异步产生）过快，导致挂起线程过多，内存不足，导致程序崩溃，消息丢失。

![avator](https://blackdog.oss-cn-qingdao.aliyuncs.com/blog/kfk-lost-3.png/s)

![avator](https://blackdog.oss-cn-qingdao.aliyuncs.com/blog/kfk-lost-4.png/s)
根据上图，可以想到几个解决的思路：
- 异步发送消息改为同步发送消。或者service产生消息时，使用阻塞的线程池，并且线程数有一定上限。整体思路是控制消息产生速度。
- 扩大Buffer的容量配置。这种方式可以缓解该情况的出现，但不能杜绝。
- service不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。相当于是在buffer和service之间又加了一层空间更加富裕的缓冲层。

#### 1.3.2.3. 在Consumer中出现消息丢失
##### 1.3.2.3.1. 消费步骤
Consumer消费消息有下面几个步骤：
1.接收消息
2.处理消息
3.反馈“处理完毕”（commited）

##### 1.3.2.3.2. 消费方式
1.自动提交offset，Automatic Offset Committing
2.手动提交offset，Manual Offset Control


##### 1.3.2.3.3. consumer丢失消息代码分析
Consumer自动提交的机制是根据一定的时间间隔，将收到的消息进行commit。commit过程和消费消息的过程是异步的。也就是说，可能存在消费过程未成功（比如抛出异常），commit消息已经提交了。此时消息就丢失了。
```
    Properties props = new Properties();
    props.put("bootstrap.servers", "localhost:9092");
    props.put("group.id", "test");
    // 自动提交开关
    props.put("enable.auto.commit", "true");
    // 自动提交的时间间隔，此处是1s
    props.put("auto.commit.interval.ms", "1000");
    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
    consumer.subscribe(Arrays.asList("foo", "bar"));
    while (true) {
            // 调用poll后，1000ms后，消息状态会被改为 committed
      ConsumerRecords<String, String> records = consumer.poll(100);
      for (ConsumerRecord<String, String> record : records)
        insertIntoDB(record); // 将消息入库，时间可能会超过1000ms
    }
```
上面的示例是自动提交的例子。如果此时，`insertIntoDB(record)`发生异常，消息将会出现丢失。接下来是手动提交的例子：
```
    Properties props = new Properties();
    props.put("bootstrap.servers", "localhost:9092");
    props.put("group.id", "test");
    // 关闭自动提交，改为手动提交
    props.put("enable.auto.commit", "false");
    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
    consumer.subscribe(Arrays.asList("foo", "bar"));
    final int minBatchSize = 200;
    List<ConsumerRecord<String, String>> buffer = new ArrayList<>();
    while (true) {
            // 调用poll后，不会进行auto commit
      ConsumerRecords<String, String> records = consumer.poll(100);
      for (ConsumerRecord<String, String> record : records) {
        buffer.add(record);
      }
      if (buffer.size() >= minBatchSize) {
        insertIntoDb(buffer);
                    // 所有消息消费完毕以后，才进行commit操作
        consumer.commitSync();
        buffer.clear();
      }
    }
```

上面两个例子，是直接使用Consumer的High level API，客户端对于offset等控制是透明的。也可以采用Low level API的方式，手动控制offset，也可以保证消息不丢，不过会更加复杂。

```
     try {
         while(running) {
             ConsumerRecords<String, String> records = consumer.poll(Long.MAX_VALUE);
             for (TopicPartition partition : records.partitions()) {
                 List<ConsumerRecord<String, String>> partitionRecords = records.records(partition);
                 for (ConsumerRecord<String, String> record : partitionRecords) {
                     System.out.println(record.offset() + ": " + record.value());
                 }
                 long lastOffset = partitionRecords.get(partitionRecords.size() - 1).offset();
                 // 精确控制offset
                 consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(lastOffset + 1)));
             }
         }
     } finally {
       consumer.close();
     }
```


