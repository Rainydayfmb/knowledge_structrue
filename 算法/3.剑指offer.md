# 剑指offer

## 8.求旋转数组的的最小数字
### 题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如 数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1
### 思路
利用二分法，找到数组的中间元素 mid。如果中间元素 > 数组第一个元素， 在 mid 右边搜索变化点。如果中间元素 < 数组第一个元素，我们需要在 mid 左边 搜索变化点。当找到变化点时停止搜索，满足 nums[mid] > nums[mid + 1] (mid+1 是最小值)或 nums[mid - 1] > nums[mid]( mid 是最小值)即可。
### 代码实现
```java
public static int minInReversingList(int[] array) { 
    if (array == null || array.length == 0){
         return -1;
    }
    if (array.length == 1 || array[array.length - 1] > array[0]){
        return array[0];
    }
    int left = 0;
    int right = array.length - 1; 
    while (left <= right) {
        int mid = (left + right) / 2;
        if (array[mid] > array[mid + 1]) {
            return array[mid + 1]; }
        if (array[mid - 1] > array[mid]) {
            return array[mid]; }
        if (array[mid] > array[0]) { 
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return -1; 
}
```

## 17.合并两个有序链表
### 题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需
要合成后的链表满足单调不减规则。
### 思路
递归与非递归求解，小数放在前面。
### 代码实现
```java
public ListNode mergeTwoLists2(ListNode list1, ListNode list2) {
    ListNode preHead = new ListNode(-1);
    ListNode pre = preHead;
    while(list1 != null && list2 != null){
        if (list1.val < list2.val){
            pre.next = list1;
            list1 = list1.next; 
        }else{
            pre.next = list2;
            list2 = list2.next;
        }
        pre = pre.next;
    }
    pre.next = list1 == null ? list2 : list1;
    return preHead.next; 
}
```

## 44.扑克牌顺子【美团】
### 题目描述
从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是 连续的。2~10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，大小王可以看成 任意数字。
### 思路
用数组记录五张扑克牌，将数组调整为有序的，若0出现的次数>=顺子的 差值，即为顺子。
### 代码实现

```java
import java.util.Arrays;
public class Solution {
    public boolean isContinuous(int [] numbers) {
        int zero = 0, dis = 0;
        if(numbers.length != 5)
            return false;
        Arrays.sort(numbers);
        for(int i = 0; i<4; i++){
            if(numbers[i] == 0){
                zero ++;
                continue;
            }
            if(numbers[i] == numbers[i+1])
                return false;
            if(numbers[i+1] - numbers[i] > 1){
                dis += numbers[i+1] - numbers[i] - 1;
            }
        }
        if(zero >= dis)
            return true;
        else
            return false;
    }
}
```

## 45.孩子们的游戏(圆圈中最后剩下的数)【快手】
### 题目描述
0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。
### 思路
[思路](https://segmentfault.com/a/1190000015932138)
```Java
import java.util.LinkedList;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(m == 0 || n == 0){
            return -1;
        }
        LinkedList<Integer> list = new LinkedList();
        for(int i = 0; i<n; i++){
            list.add(i);
        }
        int index = -1;
        while(list.size()>1){
            index = (index+m)%list.size();
            list.remove(index);
            index--;
        }
        return list.get(0);
    }
}
```
### 代码实现
```java
public static int lastRemain(int n, int m) { 
    if (n < 1 || m < 1){
        return -1; 
    }
    int last = 0;
    for (int i = 2; i <= n; i ++) {
        // i 个人时删除数的索引等于 i-1 个人时删除数的索引+k(再对 i 取余)
        last = (last + m) % i; 
    }
    return last; 
}
```

