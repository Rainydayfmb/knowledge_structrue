# 设计模式
## 单例模式
饱汉模式(懒汉模式)--双重加锁检查DCL（Double Check Lock）
```java
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(uniqueInstance == null){
        // B线程检测到uniqueInstance不为空
            synchronized(Singleton.class){
                if(uniqueInstance == null){
                    uniqueInstance = new Singleton();
                    // A线程被指令重排了，刚好先赋值了；但还没执行完构造函数。
                }
            }
        }
        return uniqueInstance;// 后面B线程执行时将引发：对象尚未初始化错误。
    }
}
```
**为什么要使用volatile关键字**
具体来说就是synchronized虽然保证了原子性，但却没有保证指令重排序的正确性，会出现A线程执行初始化，但可能因为构造函数里面的操作太多了，所以A线程的uniqueInstance实例还没有造出来，但已经被赋值了(指令重排，先赋值,但还没执行完构造函数)。而B线程这时过来了，错以为uniqueInstance已经被实例化出来，一用才发现uniqueInstance尚未被初始化，报错。要知道我们的线程虽然可以保证原子性，但程序可能是在多核CPU上执行。


**synchronized不是也具有禁止指令重排序的功能吗，为什么还要用到volatile？**

这里是需要的，不知道别人怎么理解的，但是这里synchronized 并不能保证在它之前的非空判断的“正确性”问题（if(uniqueInstance == null){...}），多线程模式下，第一层非空判断是会被突破的，所以用volatile来保证uniqueInstance的可见性，确保第一层非空判断的正确。

**volatile关键字原理**
对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。

但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议

缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。
### 策略模式
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。可以省略代码中大量的if-else代码，下面是使用java的枚举实现策略模式
一般的实现方法
```java
if (strategy.equals("fast")) {
  // 快速执行
} else if (strategy.equals("normal")) {
  // 正常执行
} else if (strategy.equals("smooth")) {
  // 平滑执行
} else if (strategy.equals("slow")) {
  // 慢慢执行
}
```
使用策略模式实现的方法如下
```java
public enum Strategy {
    FAST {
      @Override
      void run() {
        //do something
      }
    },
    NORMAL {
      @Override
       void run() {
         //do something
      }
    },
    SMOOTH {
      @Override
       void run() {
         //do something
      }
    },
    SLOW {
      @Override
       void run() {
         //do something
      }
    };
    abstract void run();
}
```
客户端的代码如下
```java
Strategy strategy = Strategy.valueOf(param);
strategy.run();
```
