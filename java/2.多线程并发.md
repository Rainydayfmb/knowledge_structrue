

# 1. 并发
<!-- TOC -->

- [1. 并发](#1-并发)
    - [1.1. 典型场景问题](#11-典型场景问题)
        - [1.1.1. 场景一 ABCABC 按照顺序执行](#111-场景一-abcabc-按照顺序执行)
        - [1.1.2. 场景二 使用“生产者-消费者模式”编写代码实现：线程A随机间隔（10~200ms）按顺序生成1到100的数字（共100个），](#112-场景二-使用生产者-消费者模式编写代码实现线程a随机间隔10200ms按顺序生成1到100的数字共100个)
    - [1.2. java并发编程](#12-java并发编程)
        - [1.2.1. 核心理论](#121-核心理论)
            - [1.2.1.1. 共享性](#1211-共享性)
            - [1.2.1.2. 互斥性](#1212-互斥性)
            - [1.2.1.3. 原子性](#1213-原子性)
            - [1.2.1.4. 可见性](#1214-可见性)
            - [1.2.1.5. 有序性](#1215-有序性)
        - [1.2.2. Synchronized及其实现原理](#122-synchronized及其实现原理)
            - [1.2.2.1. Synchronized的基本使用](#1221-synchronized的基本使用)
            - [1.2.2.2. Synchronized原理](#1222-synchronized原理)
            - [1.2.2.3. 运行结果解释](#1223-运行结果解释)
            - [1.2.2.4. 总结](#1224-总结)
        - [1.2.3. Synchronized底层优化（偏向锁、轻量级锁）](#123-synchronized底层优化偏向锁轻量级锁)
            - [1.2.3.1. 重量级锁](#1231-重量级锁)
            - [1.2.3.2. 轻量级锁](#1232-轻量级锁)
                - [1.2.3.2.1. 轻量级锁的加锁过程](#12321-轻量级锁的加锁过程)
                - [1.2.3.2.2. 轻量级锁的解锁过程](#12322-轻量级锁的解锁过程)
                - [1.2.3.2.3. 轻量级锁加锁减锁流程](#12323-轻量级锁加锁减锁流程)
            - [1.2.3.3. 偏向锁](#1233-偏向锁)
                - [1.2.3.3.1. 偏向锁获取过程](#12331-偏向锁获取过程)
                - [1.2.3.3.2. 偏向锁的释放](#12332-偏向锁的释放)
            - [1.2.3.4. 其他优化](#1234-其他优化)
                - [1.2.3.4.1. 适应性自旋（Adaptive Spinning）](#12341-适应性自旋adaptive-spinning)
                - [1.2.3.4.2. 锁粗化（Lock Coarsening）](#12342-锁粗化lock-coarsening)
                - [1.2.3.4.3. 锁消除（Lock Elimination）](#12343-锁消除lock-elimination)
            - [1.2.3.5. 总结](#1235-总结)
    - [1.3. 多线程JUC框架](#13-多线程juc框架)
        - [1.3.1. juc-locks锁框架](#131-juc-locks锁框架)
            - [1.3.1.1. (1)接口说明](#1311-1接口说明)
                - [1.3.1.1.1. 一、Lock接口简介](#13111-一lock接口简介)
                - [1.3.1.1.2. 二、Condition接口简介](#13112-二condition接口简介)
                - [1.3.1.1.3. 三、ReadWriteLock接口简介](#13113-三readwritelock接口简介)
            - [1.3.1.2. (2)ReentrantLock 的使用](#1312-2reentrantlock-的使用)
                - [1.3.1.2.1. 一、ReentrantLock类简介](#13121-一reentrantlock类简介)
                - [1.3.1.2.2. 二、ReentrantLock类原理](#13122-二reentrantlock类原理)
            - [1.3.1.3. (3)ReentrantReadWriteLock的使用](#1313-3reentrantreadwritelock的使用)
                - [1.3.1.3.1. 一、ReentrantReadWriteLock类简介](#13131-一reentrantreadwritelock类简介)
                - [1.3.1.3.2. 二、ReentrantReadWriteLock类/方法声明](#13132-二reentrantreadwritelock类方法声明)
            - [1.3.1.4. <span id = "lockSupport">(4)LockSupport 工具类</span>](#1314-span-id--locksupport4locksupport-工具类span)
                - [1.3.1.4.1. 一、LockSupport类简介](#13141-一locksupport类简介)
                - [1.3.1.4.2. 二、LockSupport类/方法声明](#13142-二locksupport类方法声明)
            - [1.3.1.5. (5)AbstractQueuedSynchronizer 综述](#1315-5abstractqueuedsynchronizer-综述)
                - [1.3.1.5.1. 一、AQS简介](#13151-一aqs简介)
                - [1.3.1.5.2. 二、AQS方法说明](#13152-二aqs方法说明)
                - [1.3.1.5.3. 三、AQS原理简述](#13153-三aqs原理简述)
                - [1.3.1.5.4. 四、总结](#13154-四总结)
            - [1.3.1.6. (7)Condition 原理](#1316-7condition-原理)
        - [1.3.2. juc-atomic原子类框架](#132-juc-atomic原子类框架)
        - [1.3.3. juc-sync 同步器框架](#133-juc-sync-同步器框架)
            - [1.3.3.1. (3)信号量——Semaphore](#1331-3信号量semaphore)
                - [1.3.3.1.1. 一、Semaphore简介](#13311-一semaphore简介)
        - [1.3.4. juc-collections 集合框架](#134-juc-collections-集合框架)
            - [1.3.4.1. 阻塞队列简介——BlockingQueue](#1341-阻塞队列简介blockingqueue)
            - [1.3.4.2. ArrayBlockingQueue](#1342-arrayblockingqueue)
        - [1.3.5. juc-executors 执行器框架](#135-juc-executors-执行器框架)

<!-- /TOC -->

## 1.1. 典型场景问题
### 1.1.1. 场景一 ABCABC 按照顺序执行
```Java
import java.util.concurrent.Semaphore;
public class ABC_Semaphore {
    // 以A开始的信号量,初始信号量数量为1
    private static Semaphore A = new Semaphore(1);
    // B、C信号量,A完成后开始,初始信号数量为0
    private static Semaphore B = new Semaphore(0);
    private static Semaphore C = new Semaphore(0);
    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    A.acquire();// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量
                    System.out.print("A");
                    B.release();// B释放信号，B信号量加1（初始为0），此时可以获取B信号量
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    B.acquire();
                    System.out.print("B");
                    C.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    C.acquire();
                    System.out.println("C");
                    A.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
```
### 1.1.2. 场景二 使用“生产者-消费者模式”编写代码实现：线程A随机间隔（10~200ms）按顺序生成1到100的数字（共100个），
放到某个队列中.线程B、C、D即时消费这些数据，线程B消费所有被3整除的数，
线程C消费所有被5整除的数，其它的由线程D进行消费。线程BCD消费这些数据时在控制台中打印出来，
要求按顺序打印这些数据
```java
import java.util.LinkedList;
import java.util.PrimitiveIterator;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test {

    static class MyQueue {

        private Queue<Integer> queue = new LinkedList<>();

        private PrimitiveIterator.OfLong longs = new Random().longs(10, 200).iterator();

        private Lock lock = new ReentrantLock();

        private Condition b = lock.newCondition();
        private Condition c = lock.newCondition();
        private Condition d = lock.newCondition();

        public int b_pull() {
            lock.lock();
            try {
                try {
                    b.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                lock.unlock();
            }
            return queue.remove();
        }

        public int c_pull() {
            lock.lock();
            try {
                try {
                    c.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                lock.unlock();
            }
            return queue.remove();
        }

        public int d_pull() {
            lock.lock();
            try {
                try {
                    d.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                lock.unlock();
            }
            return queue.remove();
        }

        public void start() {
            new Thread(() -> {
                for (int i = 1; i <= 100; i++) {
                    queue.add(i);
                    lock.lock();
                    try {
                        if (i % 3 == 0) {
                            b.signal();
                        } else if (i % 5 == 0) {
                            c.signal();
                        } else {
                            d.signal();
                        }
                    } finally {
                        lock.unlock();
                    }
                    try {
                        TimeUnit.MILLISECONDS.sleep(longs.nextLong());
                    } catch (InterruptedException ignore) {

                    }
                }
                System.out.println("all numbers are produced.");
            }).start();
        }
    }

    public static void main(String[] args) {
        MyQueue queue = new MyQueue();
        new Thread(() -> {
            while (true) {
                System.out.println(String.format("B(mod 3) consume : %d", queue.b_pull()));
            }
        }).start();
        new Thread(() -> {
            while (true) {
                System.out.println(String.format("C(mod 5) consume : %d", queue.c_pull()));
            }
        }).start();
        new Thread(() -> {
            while (true) {
                System.out.println(String.format("D(other) consume : %d", queue.d_pull()));
            }
        }).start();
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        queue.start();
    }
}

```

## 1.2. java并发编程
[Java 并发编程：核心理论](https://www.cnblogs.com/paddix/p/5374810.html)
[openJDK](https://wiki.openjdk.java.net/display/HotSpot/Synchronization)
### 1.2.1. 核心理论
#### 1.2.1.1. 共享性
数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。我们现在，通过一个简单的示例来演示多线程下共享数据导致的问题：
```java
package com.paddx.test.concurrent;
 
public class ShareData {
    public static int count = 0;
 
    public static void main(String[] args) {
        final ShareData data = new ShareData();
        for (int i = 0; i < 10; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //进入的时候暂停1毫秒，增加并发问题出现的几率
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    for (int j = 0; j < 100; j++) {
                        data.addCount();
                    }
                    System.out.print(count + " ");
                }
            }).start();
 
        }
        try {
            //主程序暂停3秒，以保证上面的程序执行完成
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("count=" + count);
    }
 
    public void addCount() {
        count++;
    }
}
```
输出的结果并不一定是1000。

#### 1.2.1.2. 互斥性
资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。但是对共享数据的写操作，一般就需要保证互斥性，上述例子中就是因为没有保证互斥性才导致数据的修改产生问题。Java 中提供多种机制来保证互斥性，最简单的方式是使用Synchronized。现在我们在上面程序中加上Synchronized再执行：
```java
 
public class ShareData {
    public static int count = 0;
 
    public static void main(String[] args) {
        final ShareData data = new ShareData();
        for (int i = 0; i < 10; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //进入的时候暂停1毫秒，增加并发问题出现的几率
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    for (int j = 0; j < 100; j++) {
                        data.addCount();
                    }
                    System.out.print(count + " ");
                }
            }).start();
 
        }
        try {
            //主程序暂停3秒，以保证上面的程序执行完成
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("count=" + count);
    }
 
    /**
     * 增加 synchronized 关键字
     */
    public synchronized void addCount() {
        count++;
    }
}
```
#### 1.2.1.3. 原子性
　原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：（1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。这个过程在多线程下就可能出现如下现象：
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160410215649812-831081790.png)
这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。

#### 1.2.1.4. 可见性
 　　要理解可见性，需要先对JVM的内存模型有一定的了解，JVM的内存模型与操作系统类似，如图所示：
 ![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160412075618645-61482019.png)
 从这个图中我们可以看出，每个线程都有一个自己的工作内存（相当于CPU高级缓冲区，这么做的目的还是在于进一步缩小存储系统与CPU之间速度的差异，提高性能），对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。通过下面这段程序我们可以演示一下不可见的问题：
 ```java
 package com.paddx.test.concurrent;
 
public class VisibilityTest {
    private static boolean ready;
    private static int number;
 
    private static class ReaderThread extends Thread {
        public void run() {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (!ready) {
                System.out.println(ready);
            }
            System.out.println(number);
        }
    }
 
    private static class WriterThread extends Thread {
        public void run() {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            number = 100;
            ready = true;
        }
    }
 
    public static void main(String[] args) {
        new WriterThread().start();
        new ReaderThread().start();
    }
}
 ```
从直观上理解，这段程序应该只会输出100，ready的值是不会打印出来的。实际上，如果多次执行上面代码的话，可能会出现多种不同的结果：false,100。true,100。
当然，这个结果也只能说是有可能是可见性造成的，当写线程（WriterThread）设置ready=true后，读线程（ReaderThread）看不到修改后的结果，所以会打印false，对于第二个结果，也就是执行if (!ready)时还没有读取到写线程的结果，但执行System.out.println(ready)时读取到了写线程执行的结果。不过，这个结果也有可能是线程的交替执行所造成的。Java 中可通过Synchronized或Volatile来保证可见性，具体细节会在后续的文章中分析。

#### 1.2.1.5. 有序性
为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为三种：
- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
我们可以直接参考一下JSR 133 中对重排序问题的描述：
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160410230317750-706312098.png)
先看上图中的（1）源码部分，从源码来看，要么指令 1 先执行要么指令 3先执行。如果指令 1 先执行，r2不应该能看到指令 4 中写入的值。如果指令 3 先执行，r1不应该能看到指令 2 写的值。但是运行结果却可能出现r2==2，r1==1的情况，这就是“重排序”导致的结果。上图（2）即是一种可能出现的合法的编译结果，编译后，指令1和指令2的顺序可能就互换了。因此，才会出现r2==2，r1==1的结果。Java 中也可通过Synchronized或Volatile来保证顺序性。

### 1.2.2. Synchronized及其实现原理
#### 1.2.2.1. Synchronized的基本使用
Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。
Synchronized的作用主要有三个：
（1）确保线程互斥的访问同步代码
（2）保证共享变量的修改能够及时可见
（3）有效解决重排序问题。

从语法上讲，Synchronized总共有三种用法：
（1）修饰普通方法
（2）修饰静态方法
（3）修饰代码块

接下来我就通过几个例子程序来说明一下这三种使用方式（为了便于比较，三段代码除了Synchronized的使用方式不同以外，其他基本保持一致）。
1、 没有同步的情况：
```java
package com.paddx.test.concurrent;

public class SynchronizedTest {
    public void method1(){
        System.out.println("Method 1 start");
        try {
            System.out.println("Method 1 execute");
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 1 end");
    }

    public void method2(){
        System.out.println("Method 2 start");
        try {
            System.out.println("Method 2 execute");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 2 end");
    }

    public static void main(String[] args) {
        final SynchronizedTest test = new SynchronizedTest();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method2();
            }
        }).start();
    }
}
```
执行结果如下，线程1和线程2同时进入执行状态，线程2执行速度比线程1快，所以线程2先执行完成，这个过程中线程1和线程2是同时执行的。
```java
Method 1 start
Method 1 execute
Method 2 start
Method 2 execute
Method 2 end
Method 1 end
```
2、对普通方法同步
```java
package com.paddx.test.concurrent;

public class SynchronizedTest {
    public synchronized void method1(){
        System.out.println("Method 1 start");
        try {
            System.out.println("Method 1 execute");
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 1 end");
    }

    public synchronized void method2(){
        System.out.println("Method 2 start");
        try {
            System.out.println("Method 2 execute");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 2 end");
    }

    public static void main(String[] args) {
        final SynchronizedTest test = new SynchronizedTest();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method2();
            }
        }).start();
    }
}
```
执行结果如下，跟代码段一比较，可以很明显的看出，线程2需要等待线程1的method1执行完成才能开始执行method2方法。
```java
Method 1 start
Method 1 execute
Method 1 end
Method 2 start
Method 2 execute
Method 2 end
```
3、静态方法（类）同步
```java
package com.paddx.test.concurrent;
 
 public class SynchronizedTest {
     public static synchronized void method1(){
         System.out.println("Method 1 start");
         try {
             System.out.println("Method 1 execute");
             Thread.sleep(3000);
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
         System.out.println("Method 1 end");
     }
 
     public static synchronized void method2(){
         System.out.println("Method 2 start");
         try {
             System.out.println("Method 2 execute");
             Thread.sleep(1000);
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
         System.out.println("Method 2 end");
     }
 
     public static void main(String[] args) {
         final SynchronizedTest test = new SynchronizedTest();
         final SynchronizedTest test2 = new SynchronizedTest();
 
         new Thread(new Runnable() {
             @Override
             public void run() {
                 test.method1();
             }
         }).start();
 
         new Thread(new Runnable() {
             @Override
             public void run() {
                 test2.method2();
             }
         }).start();
     }
 }
```
执行结果如下，对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使test和test2属于不同的对象，但是它们都属于SynchronizedTest类的实例，所以也只能顺序的执行method1和method2，不能并发执行。
```java
Method 1 start
Method 1 execute
Method 1 end
Method 2 start
Method 2 execute
Method 2 end
```
4、 代码块同步
```java
package com.paddx.test.concurrent;

public class SynchronizedTest {
    public void method1(){
        System.out.println("Method 1 start");
        try {
            synchronized (this) {
                System.out.println("Method 1 execute");
                Thread.sleep(3000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 1 end");
    }

    public void method2(){
        System.out.println("Method 2 start");
        try {
            synchronized (this) {
                System.out.println("Method 2 execute");
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Method 2 end");
    }

    public static void main(String[] args) {
        final SynchronizedTest test = new SynchronizedTest();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test.method2();
            }
        }).start();
    }
}
```
执行结果如下，虽然线程1和线程2都进入了对应的方法开始执行，但是线程2在进入同步块之前，需要等待线程1中同步块执行完成。
```java
Method 1 start
Method 1 execute
Method 2 start
Method 1 end
Method 2 execute
Method 2 end
```

#### 1.2.2.2. Synchronized原理
[通过javap命令分析java汇编指令](https://www.jianshu.com/p/6a8997560b05)
我们先通过反编译下面的代码来看看Synchronized是如何实现对代码块进行同步的：
```java
package com.paddx.test.concurrent;

public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("Method 1 start");
        }
    }
}
```
反编译的结果为
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160414215316020-1963237484.png)
**monitorenter指令**
每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
**monitorexit指令**
执行monitorexit的线程必须是objectref所对应的monitor的所有者。
指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 

通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。

我们再来看一下同步方法的反编译结果：
```java
public class SynchronizedMethod {
    public synchronized void method() {
        System.out.println("Hello World!");
    }
}
```
反编译结果
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160418202553429-1642545018.png)
从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。

#### 1.2.2.3. 运行结果解释
　有了对Synchronized原理的认识，再来看上面的程序就可以迎刃而解了。
1、代码段2结果：
　　虽然method1和method2是不同的方法，但是这两个方法都进行了同步，并且是通过同一个对象去调用的，所以调用之前都需要先去竞争同一个对象上的锁（monitor），也就只能互斥的获取到锁，因此，method1和method2只能顺序的执行。
2、代码段3结果：
　　虽然test和test2属于不同对象，但是test和test2属于同一个类的不同实例，由于method1和method2都属于静态同步方法，所以调用的时候需要获取同一个类上monitor（每个类只对应一个class对象），所以也只能顺序的执行。
3、代码段4结果：
　　对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor，由于这段代码中括号的内容都是this，而method1和method2又是通过同一的对象去调用的，所以进入同步块之前需要去竞争同一个对象上的锁，因此只能顺序执行同步块。

#### 1.2.2.4. 总结
Synchronized是Java并发编程中最常用的用于保证线程安全的方式，其使用相对也比较简单。但是如果能够深入了解其原理，对监视器锁等底层知识有所了解，一方面可以帮助我们正确的使用Synchronized关键字，另一方面也能够帮助我们更好的理解并发编程机制，有助我们在不同的情况下选择更优的并发策略来完成任务。对平时遇到的各种并发问题，也能够从容的应对。


### 1.2.3. Synchronized底层优化（偏向锁、轻量级锁）
#### 1.2.3.1. 重量级锁
Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。

#### 1.2.3.2. 轻量级锁
锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。锁的状态保存在对象的头文件中，以32位的JDK为例：
![avatar](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzMvMTZiYjUzZGJiNDEwZTMyZg)
![avatar](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzMvMTZiYjUzZTMxODY1MGZjZQ)


“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。**但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗**。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。
##### 1.2.3.2.1. 轻量级锁的加锁过程
1、在代码进入同步块的时候，如果同步对象锁为无锁状态(锁标记位为“01”状态，是否为偏向锁为“0”)，虚拟机首先在当前线程的栈帧简历一个名为锁记录(Lock Record)的空间，用于存储对象目前的Mark Word的拷贝，官方称之为Displaced Mark Word,
**(对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode)**
这时候线程堆栈与对象头的状态如下图所示。
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160424105442866-2111954866.png)
2、 拷贝对象头中的Mark Word复制到锁记录中。
3、 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指 针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。
4、 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160424105540163-1019388398.png)
5、 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

##### 1.2.3.2.2. 轻量级锁的解锁过程
- 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。
- 如果替换成功，整个同步过程就完成了。
- 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。

##### 1.2.3.2.3. 轻量级锁加锁减锁流程
![avatar](http://pic.yupoo.com/kenwug/74413954af69/custom.jpg)

#### 1.2.3.3. 偏向锁
偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，**轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能**。

##### 1.2.3.3.1. 偏向锁获取过程
1、访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。
2、如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
3、如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
4、如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
5、执行同步代码

##### 1.2.3.3.2. 偏向锁的释放
偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
![avatar](https://images2015.cnblogs.com/blog/820406/201604/820406-20160424163618101-624122079.png)

#### 1.2.3.4. 其他优化
##### 1.2.3.4.1. 适应性自旋（Adaptive Spinning）
从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

##### 1.2.3.4.2. 锁粗化（Lock Coarsening）
锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：
```java
package com.paddx.test.string;

public class StringBufferTest {
    StringBuffer stringBuffer = new StringBuffer();

    public void append(){
        stringBuffer.append("a");
        stringBuffer.append("b");
        stringBuffer.append("c");
    }
}
```
　　这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。

##### 1.2.3.4.3. 锁消除（Lock Elimination）
锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。看下面这段程序：
```java
package com.paddx.test.concurrent;

public class SynchronizedTest02 {

    public static void main(String[] args) {
        SynchronizedTest02 test02 = new SynchronizedTest02();
        //启动预热
        for (int i = 0; i < 10000; i++) {
            i++;
        }
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100000000; i++) {
            test02.append("abc", "def");
        }
        System.out.println("Time=" + (System.currentTimeMillis() - start));
    }

    public void append(String str1, String str2) {
        StringBuffer sb = new StringBuffer();
        sb.append(str1).append(str2);
    }
}
```

#### 1.2.3.5. 总结
　　本文重点介绍了JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：

锁 | 优点 | 缺点 | 适用场景
:-: | :-: | :-: | :-:
偏向锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。| 适用于只有一个线程访问同步块场景。
轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。| 追求响应时间。同步块执行速度非常快。 
 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。  |  线程阻塞，响应时间缓慢。  | 追求吞吐量。同步块执行速度较长。


## 1.3. 多线程JUC框架
本章将继续以ReentrantLock的调用为例，说明AbstractQueuedSynchronizer提供的Conditon等待功能。
[juc学习路线](https://segmentfault.com/a/1190000015558984)
线程的状态流转图
![avatar](https://img-blog.csdn.net/20150722204022168)
### 1.3.1. juc-locks锁框架
早期的JDK版本中，仅仅提供了synchronizd、wait、notify等等比较底层的多线程同步工具，开发人员如果需要开发复杂的多线程应用，通常需要基于JDK提供的这些基础工具进行封装，开发自己的工具类。JDK1.5+后，Doug Lea根据一系列常见的多线程设计模式，设计了JUC并发包，其中java.util.concurrent.locks包下提供了一系列基础的锁工具，用以对synchronizd、wait、notify等进行补充、增强。

java.util.concurrent.locks包的结构如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-b682c51008fdbb07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

包内接口和类的简单UML图如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-579a7e4e808d1336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
#### 1.3.1.1. (1)接口说明
##### 1.3.1.1.1. 一、Lock接口简介
Lock接口可以视为synchronized的增强版，提供了更灵活的功能。该接口提供了限时锁等待、锁中断、锁尝试等功能。
**1.1 接口定义**
该接口的方法声明如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-e3d9a7ae3580d149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)
需要注意lock()和lockInterruptibly()这两个方法的区别：
- lock()方法类似于使用synchronized关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。
- lockInterruptibly()方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比synchronized关键字更加灵活。

**1.2 使用示例**
可以看到，Lock作为一种同步器，一般会用一个finally语句块确保锁最终会释放。
```Java
Lock lock = ...;
if (lock.tryLock()) {
    try {
        // manipulate protected state
    } finally {
        lock.unlock();
    }
} else {
    // perform alternative actions
}
```

##### 1.3.1.1.2. 二、Condition接口简介
Condition可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用。
当线程执行condition对象的await方法时，当前线程会立即释放锁，并进入对象的等待区，等待其它线程唤醒或中断。

*JUC在实现Conditon对象时，其实是通过实现AQS框架，来实现了一个Condition等待队列，这个在后面讲AQS框架时会详细介绍，目前只要了解Condition如何使用即可。*

**2.1 接口定义**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-791238139928a012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

**2.2 使用示例**
假定有一个缓冲队列，支持 put 和 take 方法。如果试图在空队列中执行 take 操作，则线程将一直阻塞，直到队列中有可用元素；如果试图在满队列上执行 put 操作，则线程也将一直阻塞，直到队列不满。（这是一个类似于栈的数据结构）
```Java
class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)    //防止虚假唤醒，Condition的await调用一般会放在一个循环判断中
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length)
                putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length)
                takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```
等待 Condition 时，为了防止发生“虚假唤醒”， Condition 一般都是在一个循环中被等待，并测试正被等待的状态声明，如上述代码注释部分。
虽然上面这个示例程序即使不用while，改用if判断也不会出现问题，但是最佳实践还是做while循环判断——[Guarded Suspension](https://segmentfault.com/a/1190000015558585)模式，以防遗漏情况。

##### 1.3.1.1.3. 三、ReadWriteLock接口简介
ReadWriteLock接口是一个单独的接口（未继承Lock接口），该接口提供了获取读锁和写锁的方法。
*所谓读写锁，是一对相关的锁——读锁和写锁，读锁用于只读操作，写锁用于写入操作。读锁可以由多个线程同时保持，而写锁是独占的，只能由一个线程获取。*
**3.1 接口定义**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-2d24c7aee140a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420)

**3.2 使用注意**
读写锁的阻塞情况如下图：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-2ea0e462868f42e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
举个例子，假设我有一份共享数据——订单金额，大多数情况下，线程只会进行高频的数据访问（读取订单金额），数据修改（修改订单金额）的频率较低。
那么一般情况下，如果采用互斥锁，读/写和读/读都是互斥的，性能显然不如采用读写锁。
另外，由于读写锁本身的实现就远比独占锁复杂，因此，读写锁比较适用于以下情形：
- 高频次的读操作，相对较低频次的写操作；
- 读操作所用时间不会太短。（否则读写锁本身的复杂实现所带来的开销会成为主要消耗成本）

#### 1.3.1.2. (2)ReentrantLock 的使用
##### 1.3.1.2.1. 一、ReentrantLock类简介
ReentrantLock类，实现了Lock接口，是一种可重入的独占锁，它具有与使用 synchronized 相同的一些基本行为和语义，但功能更强大。ReentrantLock内部通过内部类实现了AQS框架(AbstractQueuedSynchronizer)的API来实现独占锁的功能。
**1.1 类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-3f4af1dafcda268a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
**1.2 构造声明**
ReentrantLock类提供了两类构造器：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-8cbf55700b4262cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
ReentrantLock类的其中一个构造器提供了指定公平策略 / 非公平策略的功能，默认为非公平策略。
**注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。**
**1.3 使用方式**
ReentrantLock的典型调用方式如下：
```Java
class X {
    private final ReentrantLock lock = new ReentrantLock();
    // ...
    public void m() {
        lock.lock(); // block until condition holds
        try {
            // ... method body
        } finally {
            lock.unlock();
        }
    }
}
```

##### 1.3.1.2.2. 二、ReentrantLock类原理
ReentrantLock的源码非常简单，它通过内部类实现了AQS框架，Lock接口的实现仅仅是对AQS的api的简单封装.

#### 1.3.1.3. (3)ReentrantReadWriteLock的使用
##### 1.3.1.3.1. 一、ReentrantReadWriteLock类简介
ReentrantReadWriteLock类，顾名思义，是一种读写锁，它是ReadWriteLock接口的直接实现，该类在内部实现了具体独占锁特点的写锁，以及具有共享锁特点的读锁，和ReentrantLock一样，ReentrantReadWriteLock类也是通过定义内部类实现AQS框架的API来实现独占/共享的功能。

ReentrantReadWriteLock类具有如下特点：
**1.1 支持公平/非公平策略**
与ReadWriteLock类一样，ReentrantReadWriteLock对象在构造时，可以传入参数指定是公平锁还是非公平锁。
![avatar](https://upload-images.jianshu.io/upload_images/10462182-0ee6def2495c80f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900)

**1.2 支持锁重入**
- 同一读线程在获取了读锁后还可以获取读锁;
- 同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；


**1.3 支持锁降级**
所谓锁降级，就是：先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。但是，读锁不能升级到写锁。简言之，就是：
**写锁可以降级成读锁，读锁不能升级成写锁。**

**问题**：ReentrantWriteLock 同个线程首先获取写锁后可以接着获取读锁（锁降级）以及写锁，但是获取读锁后就只能获取读锁，这个是出于什么考虑？
**答**：
这不就是读写锁的目的吗？写锁是排他锁，在一个线程持有写锁时，可以保证没有任何其他线程持有锁，相当于独占，所以它可以再持有读锁。但是反过来却不行，因为读锁并不是排他的，其他线程可能正在持有读锁或写锁，所以不能随意升级。

**1.4 Condition条件支持**
ReentrantReadWriteLock的内部读锁类、写锁类实现了Lock接口，所以可以通过newCondition()方法获取Condition对象。但是这里要注意，读锁是没法获取Condition对象的，读锁调用newCondition() 方法会直接抛出UnsupportedOperationException。

*我们知道，condition的作用其实是对Object类的wait()和notify()的增强，是为了让线程在指定对象上等待，是一种线程之间进行协调的工具。
当线程调用condition对象的await方法时，必须拿到和这个condition对象关联的锁。由于线程对读锁的访问是不受限制的（在写锁未被占用的情况下），那么即使拿到了和读锁关联的condition对象也是没有意义的，因为读线程之前不需要进行协调。*

**1.5 使用示例**
使用ReentrantReadWriteLock控制对TreeMap的访问（利用读锁控制读操作的访问，利用写锁控制修改操作的访问），将TreeMap包装成一个线程安全的集合，并且利用了读写锁的特性来提高并发访问。
```java
public class RWTreeMap {
    private final Map<String, Data> m = new TreeMap<String, Data>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public Data get(String key) {
        r.lock();
        try {
            return m.get(key);
        } finally {
            r.unlock();
        }
    }

    public String[] allKeys() {
        r.lock();
        try {
            return (String[]) m.keySet().toArray();
        } finally {
            r.unlock();
        }
    }

    public Data put(String key, Data value) {
        w.lock();
        try {
            return m.put(key, value);
        } finally {
            w.unlock();
        }
    }

    public void clear() {
        w.lock();
        try {
            m.clear();
        } finally {
            w.unlock();
        }
    }
}
```
##### 1.3.1.3.2. 二、ReentrantReadWriteLock类/方法声明
**2.1 类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-adf9297c699e65e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
内部嵌套类声明：
ReentrantReadWriteLock类有两个内部嵌套类ReadLock和WriteLock，这两个内部类的实例会在ReentrantReadWriteLock类的构造器中创建，并通过ReentrantReadWriteLock类的readLock()和writeLock()方法访问。
**ReadLock**：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-59dc4c0458a11e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**WriteLock**:
![avatar](https://upload-images.jianshu.io/upload_images/10462182-cc2716200ec9b40b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**2.2 方法声明**
ReentrantReadWriteLock类的核心方法其实就两个：readLock()和writeLock()，其它都是一些用来监控系统状态的方法，返回的都是某一时刻点的近似值。
![avatar](https://upload-images.jianshu.io/upload_images/10462182-f0b0f0d0af464999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 1.3.1.4. <span id = "lockSupport">(4)LockSupport 工具类</span>
##### 1.3.1.4.1. 一、LockSupport类简介
LockSupport类，是JUC包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞原语。

LockSupport类的核心方法其实就两个：park()和unark()，其中park()方法用来阻塞当前调用线程，unpark()方法用于唤醒指定线程。
这其实和Object类的wait()和signial()方法有些类似，但是LockSupport的这两种方法从语意上讲比Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。

**1.1 使用示例**
假设现在需要实现一种FIFO类型的独占锁，可以把这种锁看成是ReentrantLock的公平锁简单版本，且是不可重入的，就是说当一个线程获得锁后，其它等待线程以FIFO的调度方式等待获取锁。
```Java
public class FIFOMutex {
    private final AtomicBoolean locked = new AtomicBoolean(false);
    private final Queue<Thread> waiters = new ConcurrentLinkedQueue<Thread>();

    public void lock() {
        Thread current = Thread.currentThread();
        waiters.add(current);

        // 如果当前线程不在队首，或锁已被占用，则当前线程阻塞
        // NOTE：这个判断的意图其实就是：锁必须由队首元素拿到
        while (waiters.peek() != current || !locked.compareAndSet(false, true)) {
            LockSupport.park(this);
        }
        waiters.remove(); // 删除队首元素
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
}
```
上述FIFOMutex 类的实现中，当判断锁已被占用时，会调用LockSupport.park(this)方法，将当前调用线程阻塞；当使用完锁时，会调用LockSupport.unpark(waiters.peek())方法将等待队列中的队首线程唤醒。

通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。但是LockSupport的使用过程中还需要注意以下几点：
- park方法的调用一般要方法一个循环判断体里面。
如上述示例中的：
```Java
while (waiters.peek() != current || !locked.compareAndSet(false, true)) {
    LockSupport.park(this);
}
```
之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种Guarded Suspension的多线程设计模式。

-  park方法是会响应中断的，但是不会抛出异常。(也就是说如果当前调用线程被中断，则会立即返回但不会抛出中断异常)

- park的重载方法park(Object blocker)，会传入一个blocker对象，所谓Blocker对象，其实就是当前线程调用时所在调用对象（如上述示例中的FIFOMutex对象）。该对象一般供监视、诊断工具确定线程受阻塞的原因时使用。

##### 1.3.1.4.2. 二、LockSupport类/方法声明
**类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-ee8cdff500cf54aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)
**方法声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-0ceb080d026b7486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.3.1.5. (5)AbstractQueuedSynchronizer 综述

##### 1.3.1.5.1. 一、AQS简介
AQS框架提供了一套通用的机制来管理同步状态（synchronization state）、阻塞/唤醒线程、管理等待队列。ReentrantLock、CountDownLatch、CyclicBarrier都是通过AQS实现的，这些同步器的主要区别其实就是对同步状态（synchronization state）的定义不同。

AQS框架，分离了构建同步器时的一系列关注点，它的所有操作都围绕着资源——同步状态（**synchronization state**）来展开，并替用户解决了如下问题：
- 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占功能）
- 访问资源的线程如何进行并发管理？（等待队列）
- 如果线程等不及资源了，如何从等待队列退出？（超时/中断）

AQS将剩下的问题留给了用户：**什么是资源，如何定义资源是否可以被访问**？
我们来看下几个常见的同步器对这一问题的定义：
同步器 | 资源的定义
 :-:  | :-:
 ReentrantLock | 资源表示独占锁。state表示锁可用；为1表示被占用；为N表示被重入的次数
 CountDownLatch | 资源表示倒数计数器。state 0 表示计数器归零，所有的线程可以访问资源；为N表示计数器为归零，所有的线程需要阻塞；
 Semaphore | 资源表示信号量或者令牌。State《=0表示没有令牌可用，搜有线程需要阻塞；大于0表示有令牌可用，线程每获取一个令牌，State减1，线程每释放一个令牌state加1
 ReentrantReadWriteLock | 资源表示共享的读锁和独占的写锁。state逻辑上被分为两个16位的unsigned short,分别记录读锁被多少线程使用和写锁被重入的次数

**1.1 提供一套模板框架**
AQS通过暴露以下API来让让用户自己解决上面提到的“如何定义资源是否可以被访问”的问题：
钩子方法 | 描述
:-:     | :-:
tryAcquire | 排它获取（资源数）
tryRelease | 排它释放（资源数）
tryAcquireShared | 共享获取（资源数）
tryReleaseShared | 共享获取（资源数）
isHeldExclusively | 是否排它状态

**1.2 支持中断、超时**
使用了AQS框架的同步器，都支持下面的操作：
- 阻塞和非阻塞（例如tryLock）同步；
- 可选的超时设置，让调用者可以放弃等待；
- 可中断的阻塞操作。

**1.3 支持独占模式和共享模式**

**1.4 支持Condition条件等待**
Condition接口，可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用。
AQS框架内部通过一个内部类ConditionObject，实现了Condition接口，以此来为子类提供条件等待的功能。

##### 1.3.1.5.2. 二、AQS方法说明
**2.1 CAS操作**
CAS，即CompareAndSet，在Java中CAS操作的实现都委托给一个名为UnSafe类，关于Unsafe类，以后会专门详细介绍该类，目前只要知道，通过该类可以实现对字段的原子操作。
方法名 | 修饰符 | 描述
:-: | :-: | :-:
compareAndSetState | protected final | CAS修改同步状态值
compareAndSetHead  | private final | CAS修改等待队列的头指针
compareAndSetTail  | private final | CAS修改等待队列的尾指针
compareAndSetWaitStatus | private static final | CAS修改结点的等待状态
compareAndSetNext | private static final | CAS修改结点的next指针

**2.2 等待队列的核心操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
enq | private | 入队操作
addWaiter | private | 入队操作
setHead | private | 设置头结点
unparkSuccessor | private | 唤醒后继结点
doReleaseShared | private | 释放共享结点
setHeadAndPropagate | private | 设置头结点并传播唤醒

**2.3 资源的获取操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
cancelAcquire | private | 取消获取资源
shouldParkAfterFailedAcquire | private static | 判断是否阻塞当前调用线程
acquireQueued | final | 尝试获取资源,获取失败尝试阻塞线程
doAcquireInterruptibly | private | 独占地获取资源（响应中断）
doAcquireNanos | private | 独占地获取资源（限时等待）
doAcquireShared | private | 共享地获取资源
doAcquireSharedInterruptibly | private | 共享地获取资源（响应中断）
doAcquireSharedNanos | private | 共享地获取资源（限时等待）


方法名 | 修饰符 | 描述
:-: | :-: | :-:
acquire |	public final |	独占地获取资源
acquireInterruptibly 	| public final 	| 独占地获取资源（响应中断）
acquireInterruptibly 	| public final 	| 独占地获取资源（限时等待）
acquireShared |	public final 	|共享地获取资源
acquireSharedInterruptibly 	|public final 	|共享地获取资源（响应中断）
tryAcquireSharedNanos |	public final 	| 共享地获取资源（限时等待）

**2.4 资源的释放操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
release 	| public final |	释放独占资源
releaseShared |	public final |	释放共享资源

##### 1.3.1.5.3. 三、AQS原理简述
AQS的所有操作都围绕着资源-**同步状态**（synchronization state）来展开因此，围绕着资源，衍生出三个基本问题：
- 同步状态（synchronization state）的管理
- 阻塞/唤醒线程的操作
- 线程等待队列的管理

**3.1 同步状态**
同步状态，其实就是资源。AQS使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSetState操作来读取和更新这个状态。
```Java
/**
 * 同步状态.
 */
private volatile int state;

protected final int getState() {
    return state;
}

protected final void setState(int newState) {
    state = newState;
}
/**
 * 以原子的方式更新同步状态.
 * 利用Unsafe类实现
 */
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
**3.2 线程的阻塞/唤醒**
在JDK1.5之前，除了内置的监视器机制外，没有其它方法可以安全且便捷得阻塞和唤醒当前线程。
JDK1.5以后，java.util.concurrent.locks包提供了[LockSupport](#lockSupport)类来作为线程阻塞和唤醒的工具。

**3.3 等待队列**
等待队列，是AQS框架的核心，整个框架的关键其实就是如何在并发状态下管理被阻塞的线程。
//todo CLH锁

1.节点定义
CLH队列中的结点是对线程的包装，结点一共有两种类型：
- 独占（EXCLUSIVE）：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)
- 共享（SHARED）：CANCELLED(1)、SIGNAL(-1)、PROPAGATE(-3)。

结点状态 |	值 |	描述
:-: | :-: | :-:
CANCELLED |	1 |	取消。表示后驱结点被中断或超时，需要移出队列
SIGNAL    | -1 | 发信号。表示后驱结点被阻塞了（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
CONDITION | -2 | Condition专用。表示当前结点在Condition队列中，因为等待某个条件而被阻塞了
PROPAGATE | -3 | 传播。适用于共享模式（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
INITIAL | 0 | 默认。新结点会处于这种状态

AQS使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，之所以这种做是因为在双向链表的结构下，这样更容易实现取消和超时功能。

- next指针：用于维护队列顺序，当临界区的资源被释放时，头结点通过next指针找到队首结点。
- prev指针：用于在结点（线程）被取消时，让当前结点的前驱直接指向当前结点的后驱完成出队动作。

```Java
static final class Node {

    // 共享模式结点
    static final Node SHARED = new Node();

    // 独占模式结点
    static final Node EXCLUSIVE = null;

    static final int CANCELLED =  1;

    static final int SIGNAL    = -1;

    static final int CONDITION = -2;

    static final int PROPAGATE = -3;

    /**
    * INITAL：      0 - 默认，新结点会处于这种状态。
    * CANCELLED：   1 - 取消，表示后续结点被中断或超时，需要移出队列；
    * SIGNAL：      -1- 发信号，表示后续结点被阻塞了；（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
    * CONDITION：   -2- Condition专用，表示当前结点在Condition队列中，因为等待某个条件而被阻塞了；
    * PROPAGATE：   -3- 传播，适用于共享模式。（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
    *
    * waitStatus表示的是后续结点状态，这是因为AQS中使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，这样更容易实现取消和超时功能。
    */
    volatile int waitStatus;

    // 前驱指针
    volatile Node prev;

    // 后驱指针
    volatile Node next;

    // 结点所包装的线程
    volatile Thread thread;

    // Condition队列使用，存储condition队列中的后继节点
    Node nextWaiter;

    Node() {
    }

    Node(Thread thread, Node mode) {
        this.nextWaiter = mode;
        this.thread = thread;
    }
}
```

2.队列定义
对于CLH队列，当线程请求资源时，如果请求不到，会将线程包装成结点，将其挂载在队列尾部。
CLH队列的示意图如下：
①初始状态，队列head和tail都指向空
![avatar](https://image-static.segmentfault.com/740/737/740737339-5b5d4f6e5066a_articlex)

②首个线程入队，先创建一个空的头结点，然后以自旋的方式不断尝试插入一个包含当前线程的新结点
![avatar](https://image-static.segmentfault.com/410/300/4103009523-5b5d4f91e85ff_articlex)
![avatar](https://image-static.segmentfault.com/311/891/3118914716-5b5d4f9f14dd5_articlex)

```Java
/**
 * 以自旋的方式不断尝试插入结点至队列尾部
 *
 * @return 当前结点的前驱结点
 */
private Node enq(final Node node) {
    for (; ; ) {
        Node t = tail;
        if (t == null) { // 如果队列为空，则创建一个空的head结点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

##### 1.3.1.5.4. 四、总结
本章简要介绍了AQS的思想和原理，读者可以参考Doug Lea的论文，进一步了解AQS。
直接阅读AQS的源码比较漫无目的，后续章节，将从ReentrantLock、CountDownLatch的使用入手，讲解AQS的独占功能和共享功能。

#### 1.3.1.6. (7)Condition 原理

### 1.3.2. juc-atomic原子类框架
早期的JDK版本中，如果要并发的对Integer、Long、Double之类的Java原始类型或引用类型进行操作，一般都需要通过锁来控制并发，以防数据不一致。

从JDK1.5开始，引入了java.util.concurrent.atomic工具包，该包提供了许多Java原始/引用类型的映射类，如AtomicInteger、AtomicLong、AtomicBoolean，这些类可以通过一种“无锁算法”，线程安全的操作Integer、Long、Boolean等原始类型。

**关于CAS**
在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）

**CAS在JUC中的运用**
我们看一下JUC中非常重要的一个类AbstractQueuedSynchronizer，作为JAVA中多种锁实现的父类，其中有很多地方使用到了CAS操作以提升并发的效率
![avatar](https://mmbiz.qpic.cn/mmbiz_png/wXExy1PE3KMlm3PC5npFw0XOibb4Zq4Ao7N8P7eibCORiawibZsJraj4BfSOncSkljpAvalTiadlsCiczs9qjrRHiaZtw/640?wx_fmt=png)

**ABA问题**
所以JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更。

### 1.3.3. juc-sync 同步器框架

#### 1.3.3.1. (3)信号量——Semaphore

##### 1.3.3.1.1. 一、Semaphore简介
信号量，作用类似于许可证。有时，我们需要控制同时访问共享资源的最大线程数量，比如处于系统的性能考虑需要限流，或者共享资源是稀缺资源，我们需要一种方法能够协调各个线程，保证合理地使用公共资源。
semaphore维护了一个许可集：
1.当有线程需要访问资源的时候，通过先获取(acquire)；如果许可不够用了，线程会一直等待，直达徐克可用；
2.当线程使用完资源后，可以归还(release)许可，以供其他线程的使用。

### 1.3.4. juc-collections 集合框架
这里的juc-collections集合框架，是指java.util.concurrent包下的一些同步集合类，按类型划分可以分为：符号表、队列、Set集合、列表四大类，每个类都有自己适合的使用场景，整个juc-collections集合框架的结构如下图：
![avatar](https://image-static.segmentfault.com/295/701/2957013004-5b7bef685a046_articlex)
其中阻塞队列的分类及特性如下表：
队列特征|有界队列|近似无界队列|无界队列|特殊队列
:-: | :-: | :-: | :-: | :-:
有锁算法 | ArrayBlockingQueue | LinkedBlockingQueue、LinkedBlockingDeque | / |  PriorityBlockingQueue、DelayQueue
无锁算法 | / | / | LinkedTransferQueue | SynchronousQueue

#### 1.3.4.1. 阻塞队列简介——BlockingQueue
**简介**
BlockingQueue继承了Queue接口，提供了一些阻塞方法，主要作用如下：
- 当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；
- 当线程从队列中取元素（删除队列元素）时，如果队列未空，则阻塞线程，直到队列有元素；

操作类型 	| 抛出异常 |	返回特殊值 | 	阻塞线程 |	超时
:-: | :-: | :-: | :-: | :-:
插入 | add(e) |	offer(e)  | put(e) |	offer(e, time, unit)
删除 |remove() |	poll() |	take() |	poll(time, unit)
读取 |	element() |	peek() |	/  |	/
可以看到，对于每种基本方法，“抛出异常”和“返回特殊值”的方法定义和Queue是完全一样的。BlockingQueue只是增加了两类和阻塞相关的方法：put(e)、take()；offer(e, time, unit)、poll(time, unit)。

put(e)和take()方法会一直阻塞调用线程，直到线程被中断或队列状态可用；offer(e, time, unit)和poll(time, unit)方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。

```Java
public interface BlockingQueue<E> extends Queue<E> {
    /**
     * 插入元素e至队尾, 如果队列已满, 则阻塞调用线程直到队列有空闲空间.
     */
    void put(E e) throws InterruptedException;

    /**
     * 插入元素e至队列, 如果队列已满, 则限时阻塞调用线程，直到队列有空闲空间或超时.
     */
    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * 从队首删除元素，如果队列为空, 则阻塞调用线程直到队列中有元素.
     */
    E take() throws InterruptedException;

    /**
     * 从队首删除元素，如果队列为空, 则限时阻塞调用线程，直到队列中有元素或超时.
     */
    E poll(long timeout, TimeUnit unit) throws InterruptedException;

    // ...
}
```

#### 1.3.4.2. ArrayBlockingQueue
**简介**
ArrayBlockingQueue是在JDK1.5时，随着J.U.C包引入的一种阻塞队列，它实现了BlockingQueue接口，底层基于数组实现：
![avatar](https://image-static.segmentfault.com/273/434/2734343052-5b9232618f01b_articlex)
ArrayBlockingQueue是一种有界阻塞队列，在初始构造的时候需要指定队列的容量。具有如下特点：
1.队列的容量一旦在构造时指定，后续不能改变;
2.插入元素时，在队尾进行；删除元素时，在队首进行；
3.队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；
4.支持公平/非公平策略，默认为非公平策略。

*这里的公平策略，是指当线程从阻塞到唤醒后，以最初请求的顺序（FIFO）来添加或删除元素；非公平策略指线程被唤醒后，谁先抢占到锁，谁就能往队列中添加/删除顺序，是随机的。*

**原理**




### 1.3.5. juc-executors 执行器框架

countdownlatch
```Java
public class CountDownLatchTest {

    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(2);
        System.out.println("主线程开始执行…… ……");
        //第一个子线程执行
        ExecutorService es1 = Executors.newSingleThreadExecutor();
        es1.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                    System.out.println("子线程："+Thread.currentThread().getName()+"执行");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                latch.countDown();
            }
        });
        es1.shutdown();

        //第二个子线程执行
        ExecutorService es2 = Executors.newSingleThreadExecutor();
        es2.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("子线程："+Thread.currentThread().getName()+"执行");
                latch.countDown();
            }
        });
        es2.shutdown();
        System.out.println("等待两个线程执行完毕…… ……");
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("两个子线程都执行完毕，继续执行主线程");
    }
}

```

