# 1. 多线程JUC框架
<!-- TOC -->

- [1. 多线程JUC框架](#1-多线程juc框架)
    - [1.1. juc-locks锁框架](#11-juc-locks锁框架)
        - [1.1.1. (1)接口说明](#111-1接口说明)
            - [1.1.1.1. 一、Lock接口简介](#1111-一lock接口简介)
            - [1.1.1.2. 二、Condition接口简介](#1112-二condition接口简介)
            - [1.1.1.3. 三、ReadWriteLock接口简介](#1113-三readwritelock接口简介)
        - [1.1.2. (2)ReentrantLock 的使用](#112-2reentrantlock-的使用)
            - [1.1.2.1. 一、ReentrantLock类简介](#1121-一reentrantlock类简介)
            - [1.1.2.2. 二、ReentrantLock类原理](#1122-二reentrantlock类原理)
        - [1.1.3. (3)ReentrantReadWriteLock的使用](#113-3reentrantreadwritelock的使用)
            - [1.1.3.1. 一、ReentrantReadWriteLock类简介](#1131-一reentrantreadwritelock类简介)
            - [1.1.3.2. 二、ReentrantReadWriteLock类/方法声明](#1132-二reentrantreadwritelock类方法声明)
        - [1.1.4. <span id = "lockSupport">(4)LockSupport 工具类</span>](#114-span-id--locksupport4locksupport-工具类span)
            - [1.1.4.1. 一、LockSupport类简介](#1141-一locksupport类简介)
            - [1.1.4.2. 二、LockSupport类/方法声明](#1142-二locksupport类方法声明)
        - [1.1.5. (5)AbstractQueuedSynchronizer 综述](#115-5abstractqueuedsynchronizer-综述)
            - [1.1.5.1. 一、AQS简介](#1151-一aqs简介)
            - [1.1.5.2. 二、AQS方法说明](#1152-二aqs方法说明)
            - [1.1.5.3. 三、AQS原理简述](#1153-三aqs原理简述)
            - [1.1.5.4. 四、总结](#1154-四总结)
        - [1.1.6. (7)Condition 原理](#116-7condition-原理)
    - [1.2. juc-atomic原子类框架](#12-juc-atomic原子类框架)
        - [1.2.1. 更强的原子类——LongAdder简介](#121-更强的原子类longadder简介)
            - [1.2.1.1. 为什么要引入LongAdder?](#1211-为什么要引入longadder)
            - [1.2.1.2. LongAdder快在哪里？](#1212-longadder快在哪里)
            - [1.2.1.3. LongAdder能否替代AtomicLong?](#1213-longadder能否替代atomiclong)
        - [1.2.2. LongAdder原理](#122-longadder原理)
            - [1.2.2.1. LongAdder的内部结构](#1221-longadder的内部结构)
            - [1.2.2.2. LongAdder的核心方法](#1222-longadder的核心方法)
            - [1.2.2.3. Striped64的核心方法](#1223-striped64的核心方法)
                - [1.2.2.3.1. CASE2：Cell[]数组未初始化](#12231-case2cell数组未初始化)
                - [1.2.2.3.2. CASE3：Cell[]数组正在初始化中](#12232-case3cell数组正在初始化中)
                - [1.2.2.3.3. CASE1：Cell[]数组已经初始化](#12233-case1cell数组已经初始化)
            - [1.2.2.4. LongAdder的sum方法](#1224-longadder的sum方法)
        - [1.2.3. LongAdder的其它兄弟](#123-longadder的其它兄弟)
            - [1.2.3.1. LongAccumulator](#1231-longaccumulator)
            - [1.2.3.2. DoubleAdder和DoubleAccumulator](#1232-doubleadder和doubleaccumulator)
    - [1.3. juc-sync 同步器框架](#13-juc-sync-同步器框架)
        - [1.3.1. (3)信号量——Semaphore](#131-3信号量semaphore)
            - [1.3.1.1. 一、Semaphore简介](#1311-一semaphore简介)
    - [1.4. juc-collections 集合框架](#14-juc-collections-集合框架)
        - [1.4.1. 阻塞队列简介——BlockingQueue](#141-阻塞队列简介blockingqueue)
        - [1.4.2. ArrayBlockingQueue](#142-arrayblockingqueue)
    - [1.5. juc-executors 执行器框架](#15-juc-executors-执行器框架)
        - [1.5.1. executors框架概述](#151-executors框架概述)
            - [1.5.1.1. executors框架简介](#1511-executors框架简介)
                - [1.5.1.1.1. 从Executor谈起](#15111-从executor谈起)
                - [1.5.1.1.2. 增强的Executor——ExecutorService](#15112-增强的executorexecutorservice)
                - [1.5.1.1.3. 周期任务的调度——ScheduledExecutorService](#15113-周期任务的调度scheduledexecutorservice)
            - [1.5.1.2. 生产executor的工厂](#1512-生产executor的工厂)
                - [1.5.1.2.1. 固定线程数的线程池](#15121-固定线程数的线程池)
                - [1.5.1.2.2. 单个线程的线程池](#15122-单个线程的线程池)
                - [1.5.1.2.3. 可缓存的线程池](#15123-可缓存的线程池)
                - [1.5.1.2.4. 可延时/周期调度的线程池](#15124-可延时周期调度的线程池)
                - [1.5.1.2.5. Fork/Join线程池](#15125-forkjoin线程池)
            - [1.5.1.3. 总结](#1513-总结)

<!-- /TOC -->
本章将继续以ReentrantLock的调用为例，说明AbstractQueuedSynchronizer提供的Conditon等待功能。
[juc学习路线](https://segmentfault.com/a/1190000015558984)
线程的状态流转图
![avatar](https://img-blog.csdn.net/20150722204022168)
## 1.1. juc-locks锁框架
早期的JDK版本中，仅仅提供了synchronizd、wait、notify等等比较底层的多线程同步工具，开发人员如果需要开发复杂的多线程应用，通常需要基于JDK提供的这些基础工具进行封装，开发自己的工具类。JDK1.5+后，Doug Lea根据一系列常见的多线程设计模式，设计了JUC并发包，其中java.util.concurrent.locks包下提供了一系列基础的锁工具，用以对synchronizd、wait、notify等进行补充、增强。

java.util.concurrent.locks包的结构如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-b682c51008fdbb07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

包内接口和类的简单UML图如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-579a7e4e808d1336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
### 1.1.1. (1)接口说明
#### 1.1.1.1. 一、Lock接口简介
Lock接口可以视为synchronized的增强版，提供了更灵活的功能。该接口提供了限时锁等待、锁中断、锁尝试等功能。
**1.1 接口定义**
该接口的方法声明如下：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-e3d9a7ae3580d149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)
需要注意lock()和lockInterruptibly()这两个方法的区别：
- lock()方法类似于使用synchronized关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。
- lockInterruptibly()方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比synchronized关键字更加灵活。

**1.2 使用示例**
可以看到，Lock作为一种同步器，一般会用一个finally语句块确保锁最终会释放。
```Java
Lock lock = ...;
if (lock.tryLock()) {
    try {
        // manipulate protected state
    } finally {
        lock.unlock();
    }
} else {
    // perform alternative actions
}
```

#### 1.1.1.2. 二、Condition接口简介
Condition可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用。
当线程执行condition对象的await方法时，当前线程会立即释放锁，并进入对象的等待区，等待其它线程唤醒或中断。

*JUC在实现Conditon对象时，其实是通过实现AQS框架，来实现了一个Condition等待队列，这个在后面讲AQS框架时会详细介绍，目前只要了解Condition如何使用即可。*

**2.1 接口定义**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-791238139928a012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

**2.2 使用示例**
假定有一个缓冲队列，支持 put 和 take 方法。如果试图在空队列中执行 take 操作，则线程将一直阻塞，直到队列中有可用元素；如果试图在满队列上执行 put 操作，则线程也将一直阻塞，直到队列不满。（这是一个类似于栈的数据结构）
```Java
class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)    //防止虚假唤醒，Condition的await调用一般会放在一个循环判断中
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length)
                putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length)
                takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```
等待 Condition 时，为了防止发生“虚假唤醒”， Condition 一般都是在一个循环中被等待，并测试正被等待的状态声明，如上述代码注释部分。
虽然上面这个示例程序即使不用while，改用if判断也不会出现问题，但是最佳实践还是做while循环判断——[Guarded Suspension](https://segmentfault.com/a/1190000015558585)模式，以防遗漏情况。

#### 1.1.1.3. 三、ReadWriteLock接口简介
ReadWriteLock接口是一个单独的接口（未继承Lock接口），该接口提供了获取读锁和写锁的方法。
*所谓读写锁，是一对相关的锁——读锁和写锁，读锁用于只读操作，写锁用于写入操作。读锁可以由多个线程同时保持，而写锁是独占的，只能由一个线程获取。*
**3.1 接口定义**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-2d24c7aee140a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420)

**3.2 使用注意**
读写锁的阻塞情况如下图：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-2ea0e462868f42e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
举个例子，假设我有一份共享数据——订单金额，大多数情况下，线程只会进行高频的数据访问（读取订单金额），数据修改（修改订单金额）的频率较低。
那么一般情况下，如果采用互斥锁，读/写和读/读都是互斥的，性能显然不如采用读写锁。
另外，由于读写锁本身的实现就远比独占锁复杂，因此，读写锁比较适用于以下情形：
- 高频次的读操作，相对较低频次的写操作；
- 读操作所用时间不会太短。（否则读写锁本身的复杂实现所带来的开销会成为主要消耗成本）

### 1.1.2. (2)ReentrantLock 的使用
#### 1.1.2.1. 一、ReentrantLock类简介
ReentrantLock类，实现了Lock接口，是一种可重入的独占锁，它具有与使用 synchronized 相同的一些基本行为和语义，但功能更强大。ReentrantLock内部通过内部类实现了AQS框架(AbstractQueuedSynchronizer)的API来实现独占锁的功能。
**1.1 类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-3f4af1dafcda268a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
**1.2 构造声明**
ReentrantLock类提供了两类构造器：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-8cbf55700b4262cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)
ReentrantLock类的其中一个构造器提供了指定公平策略 / 非公平策略的功能，默认为非公平策略。
**注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。**
**1.3 使用方式**
ReentrantLock的典型调用方式如下：
```Java
class X {
    private final ReentrantLock lock = new ReentrantLock();
    // ...
    public void m() {
        lock.lock(); // block until condition holds
        try {
            // ... method body
        } finally {
            lock.unlock();
        }
    }
}
```

#### 1.1.2.2. 二、ReentrantLock类原理
ReentrantLock的源码非常简单，它通过内部类实现了AQS框架，Lock接口的实现仅仅是对AQS的api的简单封装.

### 1.1.3. (3)ReentrantReadWriteLock的使用
#### 1.1.3.1. 一、ReentrantReadWriteLock类简介
ReentrantReadWriteLock类，顾名思义，是一种读写锁，它是ReadWriteLock接口的直接实现，该类在内部实现了具体独占锁特点的写锁，以及具有共享锁特点的读锁，和ReentrantLock一样，ReentrantReadWriteLock类也是通过定义内部类实现AQS框架的API来实现独占/共享的功能。

ReentrantReadWriteLock类具有如下特点：
**1.1 支持公平/非公平策略**
与ReadWriteLock类一样，ReentrantReadWriteLock对象在构造时，可以传入参数指定是公平锁还是非公平锁。
![avatar](https://upload-images.jianshu.io/upload_images/10462182-0ee6def2495c80f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900)

**1.2 支持锁重入**
- 同一读线程在获取了读锁后还可以获取读锁;
- 同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；


**1.3 支持锁降级**
所谓锁降级，就是：先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。但是，读锁不能升级到写锁。简言之，就是：
**写锁可以降级成读锁，读锁不能升级成写锁。**

**问题**：ReentrantWriteLock 同个线程首先获取写锁后可以接着获取读锁（锁降级）以及写锁，但是获取读锁后就只能获取读锁，这个是出于什么考虑？
**答**：
这不就是读写锁的目的吗？写锁是排他锁，在一个线程持有写锁时，可以保证没有任何其他线程持有锁，相当于独占，所以它可以再持有读锁。但是反过来却不行，因为读锁并不是排他的，其他线程可能正在持有读锁或写锁，所以不能随意升级。

**1.4 Condition条件支持**
ReentrantReadWriteLock的内部读锁类、写锁类实现了Lock接口，所以可以通过newCondition()方法获取Condition对象。但是这里要注意，读锁是没法获取Condition对象的，读锁调用newCondition() 方法会直接抛出UnsupportedOperationException。

*我们知道，condition的作用其实是对Object类的wait()和notify()的增强，是为了让线程在指定对象上等待，是一种线程之间进行协调的工具。
当线程调用condition对象的await方法时，必须拿到和这个condition对象关联的锁。由于线程对读锁的访问是不受限制的（在写锁未被占用的情况下），那么即使拿到了和读锁关联的condition对象也是没有意义的，因为读线程之前不需要进行协调。*

**1.5 使用示例**
使用ReentrantReadWriteLock控制对TreeMap的访问（利用读锁控制读操作的访问，利用写锁控制修改操作的访问），将TreeMap包装成一个线程安全的集合，并且利用了读写锁的特性来提高并发访问。
```java
public class RWTreeMap {
    private final Map<String, Data> m = new TreeMap<String, Data>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public Data get(String key) {
        r.lock();
        try {
            return m.get(key);
        } finally {
            r.unlock();
        }
    }

    public String[] allKeys() {
        r.lock();
        try {
            return (String[]) m.keySet().toArray();
        } finally {
            r.unlock();
        }
    }

    public Data put(String key, Data value) {
        w.lock();
        try {
            return m.put(key, value);
        } finally {
            w.unlock();
        }
    }

    public void clear() {
        w.lock();
        try {
            m.clear();
        } finally {
            w.unlock();
        }
    }
}
```
#### 1.1.3.2. 二、ReentrantReadWriteLock类/方法声明
**2.1 类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-adf9297c699e65e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
内部嵌套类声明：
ReentrantReadWriteLock类有两个内部嵌套类ReadLock和WriteLock，这两个内部类的实例会在ReentrantReadWriteLock类的构造器中创建，并通过ReentrantReadWriteLock类的readLock()和writeLock()方法访问。
**ReadLock**：
![avatar](https://upload-images.jianshu.io/upload_images/10462182-59dc4c0458a11e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**WriteLock**:
![avatar](https://upload-images.jianshu.io/upload_images/10462182-cc2716200ec9b40b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**2.2 方法声明**
ReentrantReadWriteLock类的核心方法其实就两个：readLock()和writeLock()，其它都是一些用来监控系统状态的方法，返回的都是某一时刻点的近似值。
![avatar](https://upload-images.jianshu.io/upload_images/10462182-f0b0f0d0af464999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 1.1.4. <span id = "lockSupport">(4)LockSupport 工具类</span>
#### 1.1.4.1. 一、LockSupport类简介
LockSupport类，是JUC包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞原语。

LockSupport类的核心方法其实就两个：park()和unark()，其中park()方法用来阻塞当前调用线程，unpark()方法用于唤醒指定线程。
这其实和Object类的wait()和signial()方法有些类似，但是LockSupport的这两种方法从语意上讲比Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。

**1.1 使用示例**
假设现在需要实现一种FIFO类型的独占锁，可以把这种锁看成是ReentrantLock的公平锁简单版本，且是不可重入的，就是说当一个线程获得锁后，其它等待线程以FIFO的调度方式等待获取锁。
```Java
public class FIFOMutex {
    private final AtomicBoolean locked = new AtomicBoolean(false);
    private final Queue<Thread> waiters = new ConcurrentLinkedQueue<Thread>();

    public void lock() {
        Thread current = Thread.currentThread();
        waiters.add(current);

        // 如果当前线程不在队首，或锁已被占用，则当前线程阻塞
        // NOTE：这个判断的意图其实就是：锁必须由队首元素拿到
        while (waiters.peek() != current || !locked.compareAndSet(false, true)) {
            LockSupport.park(this);
        }
        waiters.remove(); // 删除队首元素
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
}
```
上述FIFOMutex 类的实现中，当判断锁已被占用时，会调用LockSupport.park(this)方法，将当前调用线程阻塞；当使用完锁时，会调用LockSupport.unpark(waiters.peek())方法将等待队列中的队首线程唤醒。

通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。但是LockSupport的使用过程中还需要注意以下几点：
- park方法的调用一般要方法一个循环判断体里面。
如上述示例中的：
```Java
while (waiters.peek() != current || !locked.compareAndSet(false, true)) {
    LockSupport.park(this);
}
```
之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种Guarded Suspension的多线程设计模式。

-  park方法是会响应中断的，但是不会抛出异常。(也就是说如果当前调用线程被中断，则会立即返回但不会抛出中断异常)

- park的重载方法park(Object blocker)，会传入一个blocker对象，所谓Blocker对象，其实就是当前线程调用时所在调用对象（如上述示例中的FIFOMutex对象）。该对象一般供监视、诊断工具确定线程受阻塞的原因时使用。

#### 1.1.4.2. 二、LockSupport类/方法声明
**类声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-ee8cdff500cf54aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)
**方法声明**
![avatar](https://upload-images.jianshu.io/upload_images/10462182-0ceb080d026b7486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.5. (5)AbstractQueuedSynchronizer 综述

#### 1.1.5.1. 一、AQS简介
AQS框架提供了一套通用的机制来管理同步状态（synchronization state）、阻塞/唤醒线程、管理等待队列。ReentrantLock、CountDownLatch、CyclicBarrier都是通过AQS实现的，这些同步器的主要区别其实就是对同步状态（synchronization state）的定义不同。

AQS框架，分离了构建同步器时的一系列关注点，它的所有操作都围绕着资源——同步状态（**synchronization state**）来展开，并替用户解决了如下问题：
- 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占功能）
- 访问资源的线程如何进行并发管理？（等待队列）
- 如果线程等不及资源了，如何从等待队列退出？（超时/中断）

AQS将剩下的问题留给了用户：**什么是资源，如何定义资源是否可以被访问**？
我们来看下几个常见的同步器对这一问题的定义：
同步器 | 资源的定义
 :-:  | :-:
 ReentrantLock | 资源表示独占锁。state表示锁可用；为1表示被占用；为N表示被重入的次数
 CountDownLatch | 资源表示倒数计数器。state 0 表示计数器归零，所有的线程可以访问资源；为N表示计数器为归零，所有的线程需要阻塞；
 Semaphore | 资源表示信号量或者令牌。State《=0表示没有令牌可用，搜有线程需要阻塞；大于0表示有令牌可用，线程每获取一个令牌，State减1，线程每释放一个令牌state加1
 ReentrantReadWriteLock | 资源表示共享的读锁和独占的写锁。state逻辑上被分为两个16位的unsigned short,分别记录读锁被多少线程使用和写锁被重入的次数

**1.1 提供一套模板框架**
AQS通过暴露以下API来让让用户自己解决上面提到的“如何定义资源是否可以被访问”的问题：
钩子方法 | 描述
:-:     | :-:
tryAcquire | 排它获取（资源数）
tryRelease | 排它释放（资源数）
tryAcquireShared | 共享获取（资源数）
tryReleaseShared | 共享获取（资源数）
isHeldExclusively | 是否排它状态

**1.2 支持中断、超时**
使用了AQS框架的同步器，都支持下面的操作：
- 阻塞和非阻塞（例如tryLock）同步；
- 可选的超时设置，让调用者可以放弃等待；
- 可中断的阻塞操作。

**1.3 支持独占模式和共享模式**

**1.4 支持Condition条件等待**
Condition接口，可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用。
AQS框架内部通过一个内部类ConditionObject，实现了Condition接口，以此来为子类提供条件等待的功能。

#### 1.1.5.2. 二、AQS方法说明
**2.1 CAS操作**
CAS，即CompareAndSet，在Java中CAS操作的实现都委托给一个名为UnSafe类，关于Unsafe类，以后会专门详细介绍该类，目前只要知道，通过该类可以实现对字段的原子操作。
方法名 | 修饰符 | 描述
:-: | :-: | :-:
compareAndSetState | protected final | CAS修改同步状态值
compareAndSetHead  | private final | CAS修改等待队列的头指针
compareAndSetTail  | private final | CAS修改等待队列的尾指针
compareAndSetWaitStatus | private static final | CAS修改结点的等待状态
compareAndSetNext | private static final | CAS修改结点的next指针

**2.2 等待队列的核心操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
enq | private | 入队操作
addWaiter | private | 入队操作
setHead | private | 设置头结点
unparkSuccessor | private | 唤醒后继结点
doReleaseShared | private | 释放共享结点
setHeadAndPropagate | private | 设置头结点并传播唤醒

**2.3 资源的获取操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
cancelAcquire | private | 取消获取资源
shouldParkAfterFailedAcquire | private static | 判断是否阻塞当前调用线程
acquireQueued | final | 尝试获取资源,获取失败尝试阻塞线程
doAcquireInterruptibly | private | 独占地获取资源（响应中断）
doAcquireNanos | private | 独占地获取资源（限时等待）
doAcquireShared | private | 共享地获取资源
doAcquireSharedInterruptibly | private | 共享地获取资源（响应中断）
doAcquireSharedNanos | private | 共享地获取资源（限时等待）


方法名 | 修饰符 | 描述
:-: | :-: | :-:
acquire |	public final |	独占地获取资源
acquireInterruptibly 	| public final 	| 独占地获取资源（响应中断）
acquireInterruptibly 	| public final 	| 独占地获取资源（限时等待）
acquireShared |	public final 	|共享地获取资源
acquireSharedInterruptibly 	|public final 	|共享地获取资源（响应中断）
tryAcquireSharedNanos |	public final 	| 共享地获取资源（限时等待）

**2.4 资源的释放操作**
方法名 | 修饰符 | 描述
:-: | :-: | :-:
release 	| public final |	释放独占资源
releaseShared |	public final |	释放共享资源

#### 1.1.5.3. 三、AQS原理简述
AQS的所有操作都围绕着资源-**同步状态**（synchronization state）来展开因此，围绕着资源，衍生出三个基本问题：
- 同步状态（synchronization state）的管理
- 阻塞/唤醒线程的操作
- 线程等待队列的管理

**3.1 同步状态**
同步状态，其实就是资源。AQS使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSetState操作来读取和更新这个状态。
```Java
/**
 * 同步状态.
 */
private volatile int state;

protected final int getState() {
    return state;
}

protected final void setState(int newState) {
    state = newState;
}
/**
 * 以原子的方式更新同步状态.
 * 利用Unsafe类实现
 */
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
**3.2 线程的阻塞/唤醒**
在JDK1.5之前，除了内置的监视器机制外，没有其它方法可以安全且便捷得阻塞和唤醒当前线程。
JDK1.5以后，java.util.concurrent.locks包提供了[LockSupport](#lockSupport)类来作为线程阻塞和唤醒的工具。

**3.3 等待队列**
等待队列，是AQS框架的核心，整个框架的关键其实就是如何在并发状态下管理被阻塞的线程。
//todo CLH锁

1.节点定义
CLH队列中的结点是对线程的包装，结点一共有两种类型：
- 独占（EXCLUSIVE）：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)
- 共享（SHARED）：CANCELLED(1)、SIGNAL(-1)、PROPAGATE(-3)。

结点状态 |	值 |	描述
:-: | :-: | :-:
CANCELLED |	1 |	取消。表示后驱结点被中断或超时，需要移出队列
SIGNAL    | -1 | 发信号。表示后驱结点被阻塞了（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
CONDITION | -2 | Condition专用。表示当前结点在Condition队列中，因为等待某个条件而被阻塞了
PROPAGATE | -3 | 传播。适用于共享模式（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
INITIAL | 0 | 默认。新结点会处于这种状态

AQS使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，之所以这种做是因为在双向链表的结构下，这样更容易实现取消和超时功能。

- next指针：用于维护队列顺序，当临界区的资源被释放时，头结点通过next指针找到队首结点。
- prev指针：用于在结点（线程）被取消时，让当前结点的前驱直接指向当前结点的后驱完成出队动作。

```Java
static final class Node {

    // 共享模式结点
    static final Node SHARED = new Node();

    // 独占模式结点
    static final Node EXCLUSIVE = null;

    static final int CANCELLED =  1;

    static final int SIGNAL    = -1;

    static final int CONDITION = -2;

    static final int PROPAGATE = -3;

    /**
    * INITAL：      0 - 默认，新结点会处于这种状态。
    * CANCELLED：   1 - 取消，表示后续结点被中断或超时，需要移出队列；
    * SIGNAL：      -1- 发信号，表示后续结点被阻塞了；（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
    * CONDITION：   -2- Condition专用，表示当前结点在Condition队列中，因为等待某个条件而被阻塞了；
    * PROPAGATE：   -3- 传播，适用于共享模式。（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
    *
    * waitStatus表示的是后续结点状态，这是因为AQS中使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，这样更容易实现取消和超时功能。
    */
    volatile int waitStatus;

    // 前驱指针
    volatile Node prev;

    // 后驱指针
    volatile Node next;

    // 结点所包装的线程
    volatile Thread thread;

    // Condition队列使用，存储condition队列中的后继节点
    Node nextWaiter;

    Node() {
    }

    Node(Thread thread, Node mode) {
        this.nextWaiter = mode;
        this.thread = thread;
    }
}
```

2.队列定义
对于CLH队列，当线程请求资源时，如果请求不到，会将线程包装成结点，将其挂载在队列尾部。
CLH队列的示意图如下：
①初始状态，队列head和tail都指向空
![avatar](https://image-static.segmentfault.com/740/737/740737339-5b5d4f6e5066a_articlex)

②首个线程入队，先创建一个空的头结点，然后以自旋的方式不断尝试插入一个包含当前线程的新结点
![avatar](https://image-static.segmentfault.com/410/300/4103009523-5b5d4f91e85ff_articlex)
![avatar](https://image-static.segmentfault.com/311/891/3118914716-5b5d4f9f14dd5_articlex)

```Java
/**
 * 以自旋的方式不断尝试插入结点至队列尾部
 *
 * @return 当前结点的前驱结点
 */
private Node enq(final Node node) {
    for (; ; ) {
        Node t = tail;
        if (t == null) { // 如果队列为空，则创建一个空的head结点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

#### 1.1.5.4. 四、总结
本章简要介绍了AQS的思想和原理，读者可以参考Doug Lea的论文，进一步了解AQS。
直接阅读AQS的源码比较漫无目的，后续章节，将从ReentrantLock、CountDownLatch的使用入手，讲解AQS的独占功能和共享功能。

### 1.1.6. (7)Condition 原理

## 1.2. juc-atomic原子类框架
早期的JDK版本中，如果要并发的对Integer、Long、Double之类的Java原始类型或引用类型进行操作，一般都需要通过锁来控制并发，以防数据不一致。

从JDK1.5开始，引入了java.util.concurrent.atomic工具包，该包提供了许多Java原始/引用类型的映射类，如AtomicInteger、AtomicLong、AtomicBoolean，这些类可以通过一种“无锁算法”，线程安全的操作Integer、Long、Boolean等原始类型。

**关于CAS**
在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）

**CAS在JUC中的运用**
我们看一下JUC中非常重要的一个类AbstractQueuedSynchronizer，作为JAVA中多种锁实现的父类，其中有很多地方使用到了CAS操作以提升并发的效率
![avatar](https://mmbiz.qpic.cn/mmbiz_png/wXExy1PE3KMlm3PC5npFw0XOibb4Zq4Ao7N8P7eibCORiawibZsJraj4BfSOncSkljpAvalTiadlsCiczs9qjrRHiaZtw/640?wx_fmt=png)

**ABA问题**
所以JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更。
### 1.2.1. 更强的原子类——LongAdder简介
JDK1.8时，java.util.concurrent.atomic包中提供了一个新的原子类：LongAdder。
根据Oracle官方文档的介绍，LongAdder在高并发的场景下会比它的前辈————AtomicLong 具有更好的性能，代价是消耗更多的内存空间：
![avatar](https://image-static.segmentfault.com/211/172/2111725197-5b62ee18e6359_articlex)

#### 1.2.1.1. 为什么要引入LongAdder?
AtomicLong是利用底层的CAS操作来提供并发性的，比如addAndGet方法：
![avatar](https://image-static.segmentfault.com/388/640/3886401211-5b62fcfc91ce0_articlex)
上述方法调用了Unsafe类的getAndAddLong方法，该方法是个native方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。
**这就是LongAdder引入的初衷——解决高并发环境下AtomicLong的自旋瓶颈问题。**

#### 1.2.1.2. LongAdder快在哪里？
既然说到LongAdder可以显著提升高并发环境下的性能，他的原理如下：
AtomicLong中有个内部变量value保存着实际的long值,所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。
LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同的槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小了很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。

#### 1.2.1.3. LongAdder能否替代AtomicLong?
AtomicLong提供的功能更加的丰富，尤其是addAndGet、decreamentAndGet、compareAndSet这些方法。
addAndGet、decrementAndGet除了单纯的做自增自减外，还可以立即获取增减后的值，而LongAdder则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的控制计数，做计数比较，AtomicLong也更合适。
另外，从空间方面考虑，LongAdder其实是一种“空间换时间”的思想，从这一点来讲AtomicLong更适合。当然，如果你一定要跟我杠现代主机的内存对于这点消耗根本不算什么，那我也办法。

总之，低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。适合的才是最好的，如果真出现了需要考虑到底用AtomicLong好还是LongAdder的业务场景，那么这样的讨论是没有意义的，因为这种情况下要么进行性能测试，以准确评估在当前业务场景下两者的性能，要么换个思路寻求其它解决方案。

### 1.2.2. LongAdder原理
之前说了，AtomicLong是多个线程针对单个热点值value进行原子造作。而LongAdder是每个线程拥有自己的槽，各个线程一般只是对自己槽中的那个值进行CAS操作。
比如有ThreadA、B、C三个线程，每个线程对value值进行加10操作。
对于AtomicLong,最终结果的计算始终是下面的形式：
value = 10 + 10 + 10;
但是对于LongAdder来说，内部有一个base变量，一个Cell[]数组。
base变量：非竞态条件下，直接累加到该变量上
cell[]数组：静态条件下，累加各个线程到自己的槽Cell[i]中，最终结果的计算是下面这个形式：
value =  base + 各个槽的累加
#### 1.2.2.1. LongAdder的内部结构
LongAdder只有一个空构造器，其本身也没有什么特殊的地方，所有复杂的逻辑都在它的父类Striped64中。
![avatar](https://image-static.segmentfault.com/197/447/1974473767-5b65617f4887b_articlex)
来看下Striped64的内部结构，这个类实现一些核心操作，处理64位数据。
Striped64只有一个空构造器，初始化时，通过Unsafe获取到类字段的偏移量，以便后续CAS操作：
![avatar](https://image-static.segmentfault.com/643/727/643727955-5b6561b4c8db4_articlex)
上面有个比较特殊的字段是threadLocalRandomProbe，可以把它看成是线程的hash值。定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过Unsafe来CAS操作它的值：
![avatar](https://image-static.segmentfault.com/234/963/2349632684-5b6561da4b1f0_articlex)
其它的字段：
可以看到Cell[]就是之前提到的槽数组，base就是非并发条件下的基数累计值。
![avatar](https://image-static.segmentfault.com/387/484/38748405-5b6561f2b5049_articlex )

#### 1.2.2.2. LongAdder的核心方法
还是通过例子来看，假设现在有一个LongAdder对象la，四个线程A、B、C、D同时对la进行累加操作。
```java
LongAdder la = new LongAdder();
la.add(10);
```
①ThreadA调用add方法（假设此时没有并发）：
![avatar](https://image-static.segmentfault.com/424/396/4243961556-5b65622031bfc_articlex)
初始时Cell[]为null，base为0。所以ThreadA会调用casBase方法（定义在Striped64中），因为没有并发，CAS操作成功将base变为10：
![avatar](https://image-static.segmentfault.com/266/599/2665990434-5b65624666e45_articlex)
可以看到，如果线程A、B、C、D线性执行，那casBase永远不会失败，也就永远不会进入到base方法的if块中，所有的值都会累积到base中。
那么，如果任意线程有并发冲突，导致caseBase失败呢？
失败就会进入if方法体：
![avatar](https://image-static.segmentfault.com/189/133/1891339934-5b656261e3aae_articlex)
这个方法体会先再次判断Cell[]槽数组有没初始化过，如果初始化过了，以后所有的CAS操作都只针对槽中的Cell；否则，进入longAccumulate方法。
整个add方法的逻辑如下图：
![avatar](https://image-static.segmentfault.com/259/179/2591798886-5b65627cc23ea_articlex)
可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。
如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。

**这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。**

#### 1.2.2.3. Striped64的核心方法
我们来看下Striped64的核心方法longAccumulate到底做了什么：
![avatar](https://image-static.segmentfault.com/293/509/2935094362-5b65633b1014d_articlex)
上述代码首先给当前线程分配一个hash值，然后进入一个自旋，这个自旋分为三个分支：
- CASE1：Cell[]数组已经初始化
- CASE2：Cell[]数组未初始化
- CASE3：Cell[]数组正在初始化中

##### 1.2.2.3.1. CASE2：Cell[]数组未初始化
我们之前讨论了，初始时Cell[]数组还没有初始化，所以会进入分支②：
![avatar](https://image-static.segmentfault.com/573/577/573577500-5b65639b05d5f_articlex)
首先会将cellsBusy置为1-加锁状态
![avatar](https://image-static.segmentfault.com/118/682/1186829995-5b6563bb20774_articlex)
然后，初始化Cell[]数组（初始大小为2），根据当前线程的hash值计算映射的索引，并创建对应的Cell对象，Cell单元中的初始值x就是本次要累加的值。

##### 1.2.2.3.2. CASE3：Cell[]数组正在初始化中
如果在初始化过程中，另一个线程ThreadB也进入了longAccumulate方法，就会进入分支③：
![avatar](https://image-static.segmentfault.com/353/417/3534179490-5b6563e517eef_articlex)
可以看到，分支③直接操作base基数，将值累加到base上。

##### 1.2.2.3.3. CASE1：Cell[]数组已经初始化
如果初始化完成后，其它线程也进入了longAccumulate方法，就会进入分支①：
![avatar](https://image-static.segmentfault.com/361/964/3619648925-5b65640ad6449_articlex)
整个longAccumulate的流程图如下：
![avatar](https://image-static.segmentfault.com/416/568/4165685425-5b65641ad10ab_articlex)

#### 1.2.2.4. LongAdder的sum方法
![avatar](https://image-static.segmentfault.com/164/193/1641936097-5b65643928281_articlex)
sum求和的公式就是我们开头说的：
value = base + cell的各个值
需要注意的是，这个方法只能得到某个时刻的近似值，这也就是LongAdder并不能完全替代LongAtomic的原因之一。

### 1.2.3. LongAdder的其它兄弟
JDK1.8时，java.util.concurrent.atomic包中，除了新引入LongAdder外，还有引入了它的三个兄弟类：LongAccumulator、DoubleAdder、DoubleAccumulator
![avatar](https://image-static.segmentfault.com/272/749/2727493376-5b65647e3d3a4_articlex)

#### 1.2.3.1. LongAccumulator
LongAccumulator是LongAdder的增强版。LongAdder只能针对数值的进行加减运算，而LongAccumulator提供了自定义的函数操作。其构造函数如下：
![avatar](https://image-static.segmentfault.com/306/829/3068299756-5b6564993deb1_articlex)
通过LongBinaryOperator，可以自定义对入参的任意操作，并返回结果（LongBinaryOperator接收2个long作为参数，并返回1个long）
LongAccumulator内部原理和LongAdder几乎完全一样，都是利用了父类Striped64的longAccumulate方法。这里就不再赘述了，读者可以自己阅读源码。

#### 1.2.3.2. DoubleAdder和DoubleAccumulator
从名字也可以看出，DoubleAdder和DoubleAccumulator用于操作double原始类型。
与LongAdder的唯一区别就是，其内部会通过一些方法，将原始的double类型，转换为long类型，其余和LongAdder完全一样：
![avatar](https://image-static.segmentfault.com/401/353/4013538878-5b6564ebca5a0_articlex)





## 1.3. juc-sync 同步器框架

### 1.3.1. (3)信号量——Semaphore

#### 1.3.1.1. 一、Semaphore简介
信号量，作用类似于许可证。有时，我们需要控制同时访问共享资源的最大线程数量，比如处于系统的性能考虑需要限流，或者共享资源是稀缺资源，我们需要一种方法能够协调各个线程，保证合理地使用公共资源。
semaphore维护了一个许可集：
1.当有线程需要访问资源的时候，通过先获取(acquire)；如果许可不够用了，线程会一直等待，直达徐克可用；
2.当线程使用完资源后，可以归还(release)许可，以供其他线程的使用。

## 1.4. juc-collections 集合框架
这里的juc-collections集合框架，是指java.util.concurrent包下的一些同步集合类，按类型划分可以分为：符号表、队列、Set集合、列表四大类，每个类都有自己适合的使用场景，整个juc-collections集合框架的结构如下图：
![avatar](https://image-static.segmentfault.com/295/701/2957013004-5b7bef685a046_articlex)
其中阻塞队列的分类及特性如下表：
队列特征|有界队列|近似无界队列|无界队列|特殊队列
:-: | :-: | :-: | :-: | :-:
有锁算法 | ArrayBlockingQueue | LinkedBlockingQueue、LinkedBlockingDeque | / |  PriorityBlockingQueue、DelayQueue
无锁算法 | / | / | LinkedTransferQueue | SynchronousQueue

### 1.4.1. 阻塞队列简介——BlockingQueue
**简介**
BlockingQueue继承了Queue接口，提供了一些阻塞方法，主要作用如下：
- 当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；
- 当线程从队列中取元素（删除队列元素）时，如果队列未空，则阻塞线程，直到队列有元素；

操作类型 	| 抛出异常 |	返回特殊值 | 	阻塞线程 |	超时
:-: | :-: | :-: | :-: | :-:
插入 | add(e) |	offer(e)  | put(e) |	offer(e, time, unit)
删除 |remove() |	poll() |	take() |	poll(time, unit)
读取 |	element() |	peek() |	/  |	/
可以看到，对于每种基本方法，“抛出异常”和“返回特殊值”的方法定义和Queue是完全一样的。BlockingQueue只是增加了两类和阻塞相关的方法：put(e)、take()；offer(e, time, unit)、poll(time, unit)。

put(e)和take()方法会一直阻塞调用线程，直到线程被中断或队列状态可用；offer(e, time, unit)和poll(time, unit)方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。

```Java
public interface BlockingQueue<E> extends Queue<E> {
    /**
     * 插入元素e至队尾, 如果队列已满, 则阻塞调用线程直到队列有空闲空间.
     */
    void put(E e) throws InterruptedException;

    /**
     * 插入元素e至队列, 如果队列已满, 则限时阻塞调用线程，直到队列有空闲空间或超时.
     */
    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * 从队首删除元素，如果队列为空, 则阻塞调用线程直到队列中有元素.
     */
    E take() throws InterruptedException;

    /**
     * 从队首删除元素，如果队列为空, 则限时阻塞调用线程，直到队列中有元素或超时.
     */
    E poll(long timeout, TimeUnit unit) throws InterruptedException;

    // ...
}
```

### 1.4.2. ArrayBlockingQueue
**简介**
ArrayBlockingQueue是在JDK1.5时，随着J.U.C包引入的一种阻塞队列，它实现了BlockingQueue接口，底层基于数组实现：
![avatar](https://image-static.segmentfault.com/273/434/2734343052-5b9232618f01b_articlex)
ArrayBlockingQueue是一种有界阻塞队列，在初始构造的时候需要指定队列的容量。具有如下特点：
1.队列的容量一旦在构造时指定，后续不能改变;
2.插入元素时，在队尾进行；删除元素时，在队首进行；
3.队列满时，调用特定方法插入元素会阻塞线程；队列空时，删除元素也会阻塞线程；
4.支持公平/非公平策略，默认为非公平策略。

*这里的公平策略，是指当线程从阻塞到唤醒后，以最初请求的顺序（FIFO）来添加或删除元素；非公平策略指线程被唤醒后，谁先抢占到锁，谁就能往队列中添加/删除顺序，是随机的。*

**原理**




## 1.5. juc-executors 执行器框架
executors框架是整个JUC包中类/接口关系最复杂的框架，executors其实可以划分为3大块，每一块的核心都是基于Excutor这个接口：
- 线程池
- Future模式
- Fork/Join框架

### 1.5.1. executors框架概述
#### 1.5.1.1. executors框架简介
juc-executors框架是整个JUC包中类/接口关系最复杂的框架，真正理解executors的前提是理清楚各个模块之间的关系，高屋建瓴，从整体到局部才能透彻理解其中各个模块和背后的设计思路。
##### 1.5.1.1.1. 从Executor谈起
Executor是JDK1.5时，随着JUC引入的一个接口，**引入该接口的主要目的是解耦任务本身和任务的执行**。我们之前通过线程执行一个任务时，往往需要先创建一个线程，然后调用线程的start方法来执行任务：
```java
new Thread(new(RunnableTask())).start();
```
上述RunableTask是实现了Runable接口的任务类
而Excutor接口任务和任务的执行，该接口只有一个方法，入参为待执行的任务：
而Executor接口解耦了任务和任务的执行，该接口只有一个方法，入参为待执行的任务：
```java
public interface Executor {
    /**
     * 执行给定的Runnable任务.
     * 根据Executor的实现不同, 具体执行方式也不相同.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be accepted for execution
     * @throws NullPointerException       if command is null
     */
    void execute(Runnable command);
}
```
我们可以像下面这样执行任务，而不必关心线程的创建：
```java
Executor executor = someExecutor;       // 创建具体的Executor对象
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
```
由于Executor仅仅是一个接口，所以根据其实现的不同，执行任务的具体方式也不尽相同，比如：
**①同步执行任务**
```java
class DirectExecutor implements Executor {   
    public void execute(Runnable r) {
        r.run();
    }
}
```
DirectExecutor是一个同步任务执行器，对于传入的任务，只有执行完成后execute才会返回。


**②异步执行任务**
```java
class ThreadPerTaskExecutor implements Executor {
    public void execute(Runnable r) {
        new Thread(r).start();
    }
}
```
ThreadPerTaskExecutor是一个异步任务执行器，对于每个任务，执行器都会创建一个新的线程去执行任务。

*注意：Java线程与本地操作系统的线程是一一映射的。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，对应操作系统线程会被回收。由于CPU资源是有限的，所以线程数量有上限，所以一般由线程池来管理线程的创建/回收，而上面这种方式其实是线程池的雏形。*

**③对任务进行排队执行**
```java
class SerialExecutor implements Executor {
  final Queue<Runnable> tasks = new ArrayDeque<Runnable>();
  final Executor executor;
  Runnable active;

  SerialExecutor(Executor executor) {
    this.executor = executor;
  }

  public synchronized void execute(final Runnable r) {
    tasks.offer(new Runnable() {
      public void run() {
       try {
         r.run();
       } finally {
         scheduleNext();
       }
      }
    });
    if (active == null) {
      scheduleNext();
    }
  }

  protected synchronized void scheduleNext() {
    if ((active = tasks.poll()) != null) {
      executor.execute(active);
    }
  }
}
```
SerialExecutor 会对传入的任务进行排队（FIFO顺序），然后从队首取出一个任务执行。

以上这些示例仅仅是给出了一些可能的Executor实现，J.U.C包中提供了很多Executor的具体实现类，我们以后会具体讲到，这里关键是理解Executor的设计思想——对任务和任务的执行解耦。

##### 1.5.1.1.2. 增强的Executor——ExecutorService
Executor接口提供的功能很简单，为了对它进行增强，JUC又提供了一个名为ExecutorService接口，ExecutorService也是在JDK1.5时，随着JUC引入的：
![avatar](https://image-static.segmentfault.com/880/187/88018759-5bb456296bc91_articlex)
可以看到，ExecutorService继承了Executor，它在Executor的基础上增强了对任务的控制，同时包括对自身生命周期的管理，主要有四类：
- 关闭执行器，禁止任务的提交；
- 监视执行器的状态；
- 提供对异步任务的支持；
- 提供对批处理任务的支持。

```java
public interface ExecutorService extends Executor {

    /**
     * 关闭执行器, 主要有以下特点:
     * 1. 已经提交给该执行器的任务将会继续执行, 但是不再接受新任务的提交;
     * 2. 如果执行器已经关闭了, 则再次调用没有副作用.
     */
    void shutdown();

    /**
     * 立即关闭执行器, 主要有以下特点:
     * 1. 尝试停止所有正在执行的任务, 无法保证能够停止成功, 但会尽力尝试(例如, 通过 Thread.interrupt中断任务, 但是不响应中断的任务可能无法终止);
     * 2. 暂停处理已经提交但未执行的任务;
     *
     * @return 返回已经提交但未执行的任务列表
     */
    List<Runnable> shutdownNow();

    /**
     * 如果该执行器已经关闭, 则返回true.
     */
    boolean isShutdown();

    /**
     * 判断执行器是否已经【终止】.
     * <p>
     * 仅当执行器已关闭且所有任务都已经执行完成, 才返回true.
     * 注意: 除非首先调用 shutdown 或 shutdownNow, 否则该方法永远返回false.
     */
    boolean isTerminated();

    /**
     * 阻塞调用线程, 等待执行器到达【终止】状态.
     *
     * @return {@code true} 如果执行器最终到达终止状态, 则返回true; 否则返回false
     * @throws InterruptedException if interrupted while waiting
     */
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 提交一个具有返回值的任务用于执行.
     * 注意: Future的get方法在成功完成时将会返回task的返回值.
     *
     * @param task 待提交的任务
     * @param <T>  任务的返回值类型
     * @return 返回该任务的Future对象
     * @throws RejectedExecutionException 如果任务无法安排执行
     * @throws NullPointerException       if the task is null
     */
    <T> Future<T> submit(Callable<T> task);

    /**
     * 提交一个 Runnable 任务用于执行.
     * 注意: Future的get方法在成功完成时将会返回给定的结果(入参时指定).
     *
     * @param task   待提交的任务
     * @param result 返回的结果
     * @param <T>    返回的结果类型
     * @return 返回该任务的Future对象
     * @throws RejectedExecutionException 如果任务无法安排执行
     * @throws NullPointerException       if the task is null
     */
    <T> Future<T> submit(Runnable task, T result);

    /**
     * 提交一个 Runnable 任务用于执行.
     * 注意: Future的get方法在成功完成时将会返回null.
     *
     * @param task 待提交的任务
     * @return 返回该任务的Future对象
     * @throws RejectedExecutionException 如果任务无法安排执行
     * @throws NullPointerException       if the task is null
     */
    Future<?> submit(Runnable task);

    /**
     * 执行给定集合中的所有任务, 当所有任务都执行完成后, 返回保持任务状态和结果的 Future 列表.
     * <p>
     * 注意: 该方法为同步方法. 返回列表中的所有元素的Future.isDone() 为 true.
     *
     * @param tasks 任务集合
     * @param <T>   任务的返回结果类型
     * @return 任务的Future对象列表，列表顺序与集合中的迭代器所生成的顺序相同，
     * @throws InterruptedException       如果等待时发生中断, 会将所有未完成的任务取消.
     * @throws NullPointerException       任一任务为 null
     * @throws RejectedExecutionException 如果任一任务无法安排执行
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;

    /**
     * 执行给定集合中的所有任务, 当所有任务都执行完成后或超时期满时（无论哪个首先发生）, 返回保持任务状态和结果的 Future 列表.
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 执行给定集合中的任务, 只有其中某个任务率先成功完成（未抛出异常）, 则返回其结果.
     * 一旦正常或异常返回后, 则取消尚未完成的任务.
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;

    /**
     * 执行给定集合中的任务, 如果在给定的超时期满前, 某个任务已成功完成（未抛出异常）, 则返回其结果.
     * 一旦正常或异常返回后, 则取消尚未完成的任务.
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

关于Future，其实就是Java多线程设计模式中Future模式,Future对象提供了对任务异步执行的支持，也就是说调用线程无需等待任务执行完成，提交待执行的任务后，就会立即返回往下执行。然后，可以在需要时检查Future是否有结果了，如果任务已执行完毕，通过Future.get()方法可以获取到执行结果——Future.get()是阻塞方法。

##### 1.5.1.1.3. 周期任务的调度——ScheduledExecutorService
在工业环境中，我们可能希望提交给执行器的某些任务能够定时执行或周期性地执行，这时我们可以自己实现Executor接口来创建符合我们需要的类，Doug Lea已经考虑到了这类需求，所以在ExecutorService的基础上，又提供了一个接口——ScheduledExecutorService，该接口也是在JDK1.5时，随着J.U.C引入的：
![avatar](https://image-static.segmentfault.com/384/898/3848981137-5bbec29e234d8_articlex)
ScheduledExecutorService提供了一系列schedule方法，可以在给定的延迟后执行提交的任务，或者每个指定的周期执行一次提交的任务，我们来看下面这个示例：
```java
public class ScheduleExecutorTest {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = someScheduler;     // 创建一个ScheduledExecutorService实例
        
        final ScheduledFuture<?> scheduledFuture = scheduler.scheduleAtFixedRate(new BeepTask(), 10, 10,
                TimeUnit.SECONDS);                              // 每隔10s蜂鸣一次
 
        scheduler.schedule(new Runnable() {
            @Override
            public void run() {
                scheduledFuture.cancel(true);
            }
        }, 1, TimeUnit.HOURS)       // 1小时后, 取消蜂鸣任务
    }
 
    private static class BeepTask implements Runnable {
        @Override
        public void run() {
            System.out.println("beep!");
        }
    }
}
```

上述示例先创建一个ScheduledExecutorService类型的执行器，然后利用scheduleAtFixedRate方法提交了一个“蜂鸣”任务，每隔10s该任务会执行一次。
*注意：scheduleAtFixedRate方法返回一个ScheduledFuture对象，ScheduledFuture其实就是在Future的基础上增加了延迟的功能。通过ScheduledFuture，可以取消一个任务的执行，本例中我们利用schedule方法，设定在1小时后，执行任务的取消。*

ScheduledExecutorService完整的接口声明如下：
```java
public interface ScheduledExecutorService extends ExecutorService {
 
    /**
     * 提交一个待执行的任务, 并在给定的延迟后执行该任务.
     *
     * @param command 待执行的任务
     * @param delay   延迟时间
     * @param unit    延迟时间的单位
     */
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
 
    /**
     * 提交一个待执行的任务（具有返回值）, 并在给定的延迟后执行该任务.
     *
     * @param command 待执行的任务
     * @param delay   延迟时间
     * @param unit    延迟时间的单位
     * @param <V>     返回值类型
     */
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
 
    /**
     * 提交一个待执行的任务.
     * 该任务在 initialDelay 后开始执行, 然后在 initialDelay+period 后执行, 接着在 initialDelay + 2 * period 后执行, 依此类推.
     *
     * @param command      待执行的任务
     * @param initialDelay 首次执行的延迟时间
     * @param period       连续执行之间的周期
     * @param unit         延迟时间的单位
     */
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
 
    /**
     * 提交一个待执行的任务.
     * 该任务在 initialDelay 后开始执行, 随后在每一次执行终止和下一次执行开始之间都存在给定的延迟.
     * 如果任务的任一执行遇到异常, 就会取消后续执行. 否则, 只能通过执行程序的取消或终止方法来终止该任务.
     *
     * @param command      待执行的任务
     * @param initialDelay 首次执行的延迟时间
     * @param delay        一次执行终止和下一次执行开始之间的延迟
     * @param unit         延迟时间的单位
     */
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
}
```
至此，Executors框架中的三个最核心的接口介绍完毕，这三个接口的关系如下图：
![avatar](https://image-static.segmentfault.com/372/401/3724012404-5bbec224900b5_articlex)

#### 1.5.1.2. 生产executor的工厂
Executors框架就是用来解耦任务本身与任务的执行，并提供了三个核心接口来满足使用者的需求：
- Executor：提交普通的可执行任务
- ExecutorService：提供对线程池生命周期的管理、异步任务的支持
- ScheduledExecutorService：提供对任务的周期性执行支持

既然上面三种执行器只是接口，那么就一定存在具体的实现类，J.U.C提供了许多默认的接口实现，如果要用户自己去创建这些类的实例，就需要了解这些类的细节，有没有一种直接的方式，仅仅根据一些需要的特性（参数）就创建这些实例呢？因为对于用户来说，其实使用的只是这三个接口。

JDK1.5时，J.U.C中还提供了一个Executors类，专门用于创建上述接口的实现类对象。Executors其实就是一个简单工厂，它的所有方法都是static的，用户可以根据需要，选择需要创建的执行器实例，Executors一共提供了五类可供创建的Executor执行器实例。

##### 1.5.1.2.1. 固定线程数的线程池
Executors提供了两种创建具有固定线程数的Executor的方法，固定线程池在初始化时确定其中的线程总数，运行过程中会始终维持线程数量不变。

可以看到下面的两种创建方法其实都返回了一个ThreadPoolExecutor实例。ThreadPoolExecutor是一个ExecutorService接口的实现类，我们会在后面用专门章节讲解，现在只需要了解这是一种Executor，用来调度其中的线程的执行即可。
```java
/**
 * 创建一个具有固定线程数的Executor.
 */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>());
}

/**
 * 创建一个具有固定线程数的Executor.
 * 在需要时使用提供的 ThreadFactory 创建新线程.
 */
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(), threadFactory);

}
```
上面需要注意的是ThreadFactory这个接口：
```java
public interface ThreadFactory {
    Thread newThread(Runnable r);
}
```
既然返回的是一个线程池，那么就涉及线程的创建，一般我们需要通过 new Thread ()这种方法创建一个新线程，但是我们可能希望设置一些线程属性，比如
名称、守护程序状态、ThreadGroup 等等，线程池中的线程非常多，如果每个线程都这样手动配置势必非常繁琐，而ThreadFactory 作为一个线程工厂可以让我们从这些繁琐的线程状态设置的工作中解放出来，还可以由外部指定ThreadFactory实例，以决定线程的具体创建方式。 

Executors提供了静态内部类，实现了ThreadFactory接口，最简单且常用的就是下面这个**DefaultThreadFactory **：
```java
/**
 * 默认的线程工厂.
 */
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;
 
    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-";
    }
 
    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}
```

可以看到，DefaultThreadFactory 初始化的时候定义了线程组、线程名称等信息，每创建一个线程，都给线程统一分配这些信息，避免了一个个手工通过new的方式创建线程，又可进行工厂的复用。

##### 1.5.1.2.2. 单个线程的线程池
```java
/**
 * 创建一个使用单个 worker 线程的 Executor.
 */
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue<Runnable>()));
}
 
/**
 * 创建一个使用单个 worker 线程的 Executor.
 * 在需要时使用提供的 ThreadFactory 创建新线程.
 */
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue<Runnable>(), threadFactory));
}
```
可以看到，只有单个线程的线程池其实就是指定线程数为1的固定线程池，主要区别就是，返回的Executor实例用了一个FinalizableDelegatedExecutorService对象进行包装。
我们来看下FinalizableDelegatedExecutorService，该类 只定义了一个finalize方法：
```java
static class FinalizableDelegatedExecutorService extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
    }
    protected void finalize() {
        super.shutdown();
    }
}
```
核心是其继承的DelegatedExecutorService ，这是一个包装类，实现了ExecutorService的所有方法，但是内部实现其实都委托给了传入的ExecutorService 实例：
```java
/**
 * ExecutorService实现类的包装类.
 */
static class DelegatedExecutorService extends AbstractExecutorService {
    private final ExecutorService e;
 
    DelegatedExecutorService(ExecutorService executor) {
        e = executor;
    }
 
    public void execute(Runnable command) {
        e.execute(command);
    }
 
    public void shutdown() {
        e.shutdown();
    }
 
    public List<Runnable> shutdownNow() {
        return e.shutdownNow();
    }
 
    public boolean isShutdown() {
        return e.isShutdown();
    }
 
    public boolean isTerminated() {
        return e.isTerminated();
    }
 
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return e.awaitTermination(timeout, unit);
    }
 
    public Future<?> submit(Runnable task) {
        return e.submit(task);
    }
 
    public <T> Future<T> submit(Callable<T> task) {
        return e.submit(task);
    }
 
    public <T> Future<T> submit(Runnable task, T result) {
        return e.submit(task, result);
    }
 
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return e.invokeAll(tasks);
    }
 
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
            throws InterruptedException {
        return e.invokeAll(tasks, timeout, unit);
    }
 
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return e.invokeAny(tasks);
    }
 
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
        return e.invokeAny(tasks, timeout, unit);
    }

}
```
为什么要多此一举，加上这样一个委托层？因为返回的ThreadPoolExecutor包含一些设置线程池大小的方法——比如setCorePoolSize，对于只有单个线程的线程池来说，我们是不希望用户通过强转的方式使用这些方法的，所以需要一个包装类，只暴露ExecutorService本身的方法。

##### 1.5.1.2.3. 可缓存的线程池
有些情况下，我们虽然创建了具有一定线程数的线程池，但出于资源利用率的考虑，可能希望在特定的时候对线程进行回收（比如线程超过指定时间没有被使用），Executors就提供了这种类型的线程池：
```java
/**
 * 创建一个可缓存线程的Execotor.
 * 如果线程池中没有线程可用, 则创建一个新线程并添加到池中;
 * 如果有线程长时间未被使用(默认60s, 可通过threadFactory配置), 则从缓存中移除.
 */
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
}
 
/**
 * 创建一个可缓存线程的Execotor.
 * 如果线程池中没有线程可用, 则创建一个新线程并添加到池中;
 * 如果有线程长时间未被使用(默认60s, 可通过threadFactory配置), 则从缓存中移除.
 * 在需要时使用提供的 ThreadFactory 创建新线程.
 */
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>(), threadFactory);
}
```
可以看到，返回的还是ThreadPoolExecutor对象，只是指定了超时时间，另外线程池中线程的数量在[0, Integer.MAX_VALUE]之间。

##### 1.5.1.2.4. 可延时/周期调度的线程池
如果有任务需要延迟/周期调用，就需要返回ScheduledExecutorService接口的实例，ScheduledThreadPoolExecutor就是实现了ScheduledExecutorService接口的一种Executor，和ThreadPoolExecutor一样，这个我们后面会专门讲解。
```java
/**
 * 创建一个具有固定线程数的 可调度Executor.
 * 它可安排任务在指定延迟后或周期性地执行.
 */
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
 
/**
 * 创建一个具有固定线程数的 可调度Executor.
 * 它可安排任务在指定延迟后或周期性地执行.
 * 在需要时使用提供的 ThreadFactory 创建新线程.
 */
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```

##### 1.5.1.2.5. Fork/Join线程池
Fork/Join线程池是比较特殊的一类线程池，在JDK1.7时才引入，其核心实现就是ForkJoinPool类。关于Fork/Join框架，我们后面会专题讲解，现在只需要知道，Executors框架提供了一种创建该类线程池的便捷方法。
```java
/**
 * 创建具有指定并行级别的ForkJoin线程池.
 */
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool(parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);
}
 
/**
 * 创建并行级别等于CPU核心数的ForkJoin线程池.
 */
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool(Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory,
            null, true);
}
```

#### 1.5.1.3. 总结
至此，Executors框架的整体结构基本就讲解完了，此时我们的脑海中应有大致如下的一幅类继承图：
![avatar](https://image-static.segmentfault.com/196/876/1968768292-5bb459b665b53_articlex)
下面来回顾一下，上面的各个接口/类的关系和作用：
- Executor
执行器接口，也是最顶层的抽象核心接口， 分离了任务和任务的执行。
- ExecutorService
在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能。
- ScheduledExecutorService
在ExecutorService基础上提供了任务的延迟执行/周期执行的功能。
- Executors
生产具体的执行器的静态工厂
- ThreadFactory
线程工厂，用于创建单个线程，减少手工创建线程的繁琐工作，同时能够复用工厂的特性。
- AbstractExecutorService
ExecutorService的抽象实现，为各类执行器类的实现提供基础。
- ThreadPoolExecutor
线程池Executor，也是最常用的Executor，可以以线程池的方式管理线程。
- ScheduledThreadPoolExecutor
在ThreadPoolExecutor基础上，增加了对周期任务调度的支持。
- ForkJoinPool
Fork/Join线程池，在JDK1.7时引入，时实现Fork/Join框架的核心类。

关于ThreadPoolExecutor和ScheduledThreadPoolExecutor，我们会在下一章详细讲解，帮助读者理解线程池的实现原理。至于ForkJoinPool，涉及Fork/Join这个并行框架的讲解，我们后面会专题介绍。




countdownlatch
```Java
public class CountDownLatchTest {

    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(2);
        System.out.println("主线程开始执行…… ……");
        //第一个子线程执行
        ExecutorService es1 = Executors.newSingleThreadExecutor();
        es1.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                    System.out.println("子线程："+Thread.currentThread().getName()+"执行");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                latch.countDown();
            }
        });
        es1.shutdown();

        //第二个子线程执行
        ExecutorService es2 = Executors.newSingleThreadExecutor();
        es2.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("子线程："+Thread.currentThread().getName()+"执行");
                latch.countDown();
            }
        });
        es2.shutdown();
        System.out.println("等待两个线程执行完毕…… ……");
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("两个子线程都执行完毕，继续执行主线程");
    }
}

```